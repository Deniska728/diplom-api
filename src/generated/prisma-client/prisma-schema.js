module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateComment {
  count: Int!
}

type AggregateCommentContent {
  count: Int!
}

type AggregateGqlBaseType {
  count: Int!
}

type AggregateGqlDirective {
  count: Int!
}

type AggregateGqlEnumValue {
  count: Int!
}

type AggregateGqlField {
  count: Int!
}

type AggregateGqlInputValue {
  count: Int!
}

type AggregateGqlIntrospectionSchema {
  count: Int!
}

type AggregateGqlSchema {
  count: Int!
}

type AggregateGqlType {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserProfile {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Comment {
  id: ID!
  content: CommentContent!
  gqlType: GqlType
  gqlField: GqlField
  createdBy: User!
  createdAt: DateTime!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

type CommentContent {
  id: ID!
  message: String!
}

type CommentContentConnection {
  pageInfo: PageInfo!
  edges: [CommentContentEdge]!
  aggregate: AggregateCommentContent!
}

input CommentContentCreateInput {
  id: ID
  message: String!
}

input CommentContentCreateOneInput {
  create: CommentContentCreateInput
  connect: CommentContentWhereUniqueInput
}

type CommentContentEdge {
  node: CommentContent!
  cursor: String!
}

enum CommentContentOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
}

type CommentContentPreviousValues {
  id: ID!
  message: String!
}

type CommentContentSubscriptionPayload {
  mutation: MutationType!
  node: CommentContent
  updatedFields: [String!]
  previousValues: CommentContentPreviousValues
}

input CommentContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentContentWhereInput
  AND: [CommentContentSubscriptionWhereInput!]
  OR: [CommentContentSubscriptionWhereInput!]
  NOT: [CommentContentSubscriptionWhereInput!]
}

input CommentContentUpdateDataInput {
  message: String
}

input CommentContentUpdateInput {
  message: String
}

input CommentContentUpdateManyMutationInput {
  message: String
}

input CommentContentUpdateOneRequiredInput {
  create: CommentContentCreateInput
  update: CommentContentUpdateDataInput
  upsert: CommentContentUpsertNestedInput
  connect: CommentContentWhereUniqueInput
}

input CommentContentUpsertNestedInput {
  update: CommentContentUpdateDataInput!
  create: CommentContentCreateInput!
}

input CommentContentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  AND: [CommentContentWhereInput!]
  OR: [CommentContentWhereInput!]
  NOT: [CommentContentWhereInput!]
}

input CommentContentWhereUniqueInput {
  id: ID
}

input CommentCreateInput {
  id: ID
  content: CommentContentCreateOneInput!
  gqlType: GqlTypeCreateOneWithoutCommentsInput
  gqlField: GqlFieldCreateOneWithoutCommentsInput
  createdBy: UserCreateOneInput!
}

input CommentCreateManyWithoutGqlFieldInput {
  create: [CommentCreateWithoutGqlFieldInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutGqlTypeInput {
  create: [CommentCreateWithoutGqlTypeInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutGqlFieldInput {
  id: ID
  content: CommentContentCreateOneInput!
  gqlType: GqlTypeCreateOneWithoutCommentsInput
  createdBy: UserCreateOneInput!
}

input CommentCreateWithoutGqlTypeInput {
  id: ID
  content: CommentContentCreateOneInput!
  gqlField: GqlFieldCreateOneWithoutCommentsInput
  createdBy: UserCreateOneInput!
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
}

type CommentPreviousValues {
  id: ID!
  createdAt: DateTime!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  content: CommentContentUpdateOneRequiredInput
  gqlType: GqlTypeUpdateOneWithoutCommentsInput
  gqlField: GqlFieldUpdateOneWithoutCommentsInput
  createdBy: UserUpdateOneRequiredInput
}

input CommentUpdateManyWithoutGqlFieldInput {
  create: [CommentCreateWithoutGqlFieldInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutGqlFieldInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutGqlFieldInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpdateManyWithoutGqlTypeInput {
  create: [CommentCreateWithoutGqlTypeInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutGqlTypeInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutGqlTypeInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpdateWithoutGqlFieldDataInput {
  content: CommentContentUpdateOneRequiredInput
  gqlType: GqlTypeUpdateOneWithoutCommentsInput
  createdBy: UserUpdateOneRequiredInput
}

input CommentUpdateWithoutGqlTypeDataInput {
  content: CommentContentUpdateOneRequiredInput
  gqlField: GqlFieldUpdateOneWithoutCommentsInput
  createdBy: UserUpdateOneRequiredInput
}

input CommentUpdateWithWhereUniqueWithoutGqlFieldInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutGqlFieldDataInput!
}

input CommentUpdateWithWhereUniqueWithoutGqlTypeInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutGqlTypeDataInput!
}

input CommentUpsertWithWhereUniqueWithoutGqlFieldInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutGqlFieldDataInput!
  create: CommentCreateWithoutGqlFieldInput!
}

input CommentUpsertWithWhereUniqueWithoutGqlTypeInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutGqlTypeDataInput!
  create: CommentCreateWithoutGqlTypeInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: CommentContentWhereInput
  gqlType: GqlTypeWhereInput
  gqlField: GqlFieldWhereInput
  createdBy: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type GqlBaseType {
  id: ID!
  kind: GqlTypeKind!
  name: String!
}

type GqlBaseTypeConnection {
  pageInfo: PageInfo!
  edges: [GqlBaseTypeEdge]!
  aggregate: AggregateGqlBaseType!
}

input GqlBaseTypeCreateInput {
  id: ID
  kind: GqlTypeKind!
  name: String!
}

input GqlBaseTypeCreateManyInput {
  create: [GqlBaseTypeCreateInput!]
  connect: [GqlBaseTypeWhereUniqueInput!]
}

type GqlBaseTypeEdge {
  node: GqlBaseType!
  cursor: String!
}

enum GqlBaseTypeOrderByInput {
  id_ASC
  id_DESC
  kind_ASC
  kind_DESC
  name_ASC
  name_DESC
}

type GqlBaseTypePreviousValues {
  id: ID!
  kind: GqlTypeKind!
  name: String!
}

input GqlBaseTypeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  kind: GqlTypeKind
  kind_not: GqlTypeKind
  kind_in: [GqlTypeKind!]
  kind_not_in: [GqlTypeKind!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [GqlBaseTypeScalarWhereInput!]
  OR: [GqlBaseTypeScalarWhereInput!]
  NOT: [GqlBaseTypeScalarWhereInput!]
}

type GqlBaseTypeSubscriptionPayload {
  mutation: MutationType!
  node: GqlBaseType
  updatedFields: [String!]
  previousValues: GqlBaseTypePreviousValues
}

input GqlBaseTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GqlBaseTypeWhereInput
  AND: [GqlBaseTypeSubscriptionWhereInput!]
  OR: [GqlBaseTypeSubscriptionWhereInput!]
  NOT: [GqlBaseTypeSubscriptionWhereInput!]
}

input GqlBaseTypeUpdateDataInput {
  kind: GqlTypeKind
  name: String
}

input GqlBaseTypeUpdateInput {
  kind: GqlTypeKind
  name: String
}

input GqlBaseTypeUpdateManyDataInput {
  kind: GqlTypeKind
  name: String
}

input GqlBaseTypeUpdateManyInput {
  create: [GqlBaseTypeCreateInput!]
  update: [GqlBaseTypeUpdateWithWhereUniqueNestedInput!]
  upsert: [GqlBaseTypeUpsertWithWhereUniqueNestedInput!]
  delete: [GqlBaseTypeWhereUniqueInput!]
  connect: [GqlBaseTypeWhereUniqueInput!]
  set: [GqlBaseTypeWhereUniqueInput!]
  disconnect: [GqlBaseTypeWhereUniqueInput!]
  deleteMany: [GqlBaseTypeScalarWhereInput!]
  updateMany: [GqlBaseTypeUpdateManyWithWhereNestedInput!]
}

input GqlBaseTypeUpdateManyMutationInput {
  kind: GqlTypeKind
  name: String
}

input GqlBaseTypeUpdateManyWithWhereNestedInput {
  where: GqlBaseTypeScalarWhereInput!
  data: GqlBaseTypeUpdateManyDataInput!
}

input GqlBaseTypeUpdateWithWhereUniqueNestedInput {
  where: GqlBaseTypeWhereUniqueInput!
  data: GqlBaseTypeUpdateDataInput!
}

input GqlBaseTypeUpsertWithWhereUniqueNestedInput {
  where: GqlBaseTypeWhereUniqueInput!
  update: GqlBaseTypeUpdateDataInput!
  create: GqlBaseTypeCreateInput!
}

input GqlBaseTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  kind: GqlTypeKind
  kind_not: GqlTypeKind
  kind_in: [GqlTypeKind!]
  kind_not_in: [GqlTypeKind!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [GqlBaseTypeWhereInput!]
  OR: [GqlBaseTypeWhereInput!]
  NOT: [GqlBaseTypeWhereInput!]
}

input GqlBaseTypeWhereUniqueInput {
  id: ID
}

type GqlDirective {
  id: ID!
  name: String!
  description: String
  locations: [GqlDirectiveLocation!]!
  args(where: GqlInputValueWhereInput, orderBy: GqlInputValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlInputValue!]
}

type GqlDirectiveConnection {
  pageInfo: PageInfo!
  edges: [GqlDirectiveEdge]!
  aggregate: AggregateGqlDirective!
}

input GqlDirectiveCreateInput {
  id: ID
  name: String!
  description: String
  locations: GqlDirectiveCreatelocationsInput
  args: GqlInputValueCreateManyInput
}

input GqlDirectiveCreatelocationsInput {
  set: [GqlDirectiveLocation!]
}

input GqlDirectiveCreateManyInput {
  create: [GqlDirectiveCreateInput!]
  connect: [GqlDirectiveWhereUniqueInput!]
}

type GqlDirectiveEdge {
  node: GqlDirective!
  cursor: String!
}

enum GqlDirectiveLocation {
  QUERY
  MUTATION
  SUBSCRIPTION
  FIELD
  FRAGMENT_DEFINITION
  FRAGMENT_SPREAD
  INLINE_FRAGMENT
  SCHEMA
  SCALAR
  OBJECT
  FIELD_DEFINITION
  ARGUMENT_DEFINITION
  INTERFACE
  UNION
  ENUM
  ENUM_VALUE
  INPUT_OBJECT
  INPUT_FIELD_DEFINITION
}

enum GqlDirectiveOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
}

type GqlDirectivePreviousValues {
  id: ID!
  name: String!
  description: String
  locations: [GqlDirectiveLocation!]!
}

input GqlDirectiveScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [GqlDirectiveScalarWhereInput!]
  OR: [GqlDirectiveScalarWhereInput!]
  NOT: [GqlDirectiveScalarWhereInput!]
}

type GqlDirectiveSubscriptionPayload {
  mutation: MutationType!
  node: GqlDirective
  updatedFields: [String!]
  previousValues: GqlDirectivePreviousValues
}

input GqlDirectiveSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GqlDirectiveWhereInput
  AND: [GqlDirectiveSubscriptionWhereInput!]
  OR: [GqlDirectiveSubscriptionWhereInput!]
  NOT: [GqlDirectiveSubscriptionWhereInput!]
}

input GqlDirectiveUpdateDataInput {
  name: String
  description: String
  locations: GqlDirectiveUpdatelocationsInput
  args: GqlInputValueUpdateManyInput
}

input GqlDirectiveUpdateInput {
  name: String
  description: String
  locations: GqlDirectiveUpdatelocationsInput
  args: GqlInputValueUpdateManyInput
}

input GqlDirectiveUpdatelocationsInput {
  set: [GqlDirectiveLocation!]
}

input GqlDirectiveUpdateManyDataInput {
  name: String
  description: String
  locations: GqlDirectiveUpdatelocationsInput
}

input GqlDirectiveUpdateManyInput {
  create: [GqlDirectiveCreateInput!]
  update: [GqlDirectiveUpdateWithWhereUniqueNestedInput!]
  upsert: [GqlDirectiveUpsertWithWhereUniqueNestedInput!]
  delete: [GqlDirectiveWhereUniqueInput!]
  connect: [GqlDirectiveWhereUniqueInput!]
  set: [GqlDirectiveWhereUniqueInput!]
  disconnect: [GqlDirectiveWhereUniqueInput!]
  deleteMany: [GqlDirectiveScalarWhereInput!]
  updateMany: [GqlDirectiveUpdateManyWithWhereNestedInput!]
}

input GqlDirectiveUpdateManyMutationInput {
  name: String
  description: String
  locations: GqlDirectiveUpdatelocationsInput
}

input GqlDirectiveUpdateManyWithWhereNestedInput {
  where: GqlDirectiveScalarWhereInput!
  data: GqlDirectiveUpdateManyDataInput!
}

input GqlDirectiveUpdateWithWhereUniqueNestedInput {
  where: GqlDirectiveWhereUniqueInput!
  data: GqlDirectiveUpdateDataInput!
}

input GqlDirectiveUpsertWithWhereUniqueNestedInput {
  where: GqlDirectiveWhereUniqueInput!
  update: GqlDirectiveUpdateDataInput!
  create: GqlDirectiveCreateInput!
}

input GqlDirectiveWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  args_every: GqlInputValueWhereInput
  args_some: GqlInputValueWhereInput
  args_none: GqlInputValueWhereInput
  AND: [GqlDirectiveWhereInput!]
  OR: [GqlDirectiveWhereInput!]
  NOT: [GqlDirectiveWhereInput!]
}

input GqlDirectiveWhereUniqueInput {
  id: ID
}

type GqlEnumValue {
  id: ID!
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

type GqlEnumValueConnection {
  pageInfo: PageInfo!
  edges: [GqlEnumValueEdge]!
  aggregate: AggregateGqlEnumValue!
}

input GqlEnumValueCreateInput {
  id: ID
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

input GqlEnumValueCreateManyInput {
  create: [GqlEnumValueCreateInput!]
  connect: [GqlEnumValueWhereUniqueInput!]
}

type GqlEnumValueEdge {
  node: GqlEnumValue!
  cursor: String!
}

enum GqlEnumValueOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  isDeprecated_ASC
  isDeprecated_DESC
  deprecationReason_ASC
  deprecationReason_DESC
}

type GqlEnumValuePreviousValues {
  id: ID!
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

input GqlEnumValueScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isDeprecated: Boolean
  isDeprecated_not: Boolean
  deprecationReason: String
  deprecationReason_not: String
  deprecationReason_in: [String!]
  deprecationReason_not_in: [String!]
  deprecationReason_lt: String
  deprecationReason_lte: String
  deprecationReason_gt: String
  deprecationReason_gte: String
  deprecationReason_contains: String
  deprecationReason_not_contains: String
  deprecationReason_starts_with: String
  deprecationReason_not_starts_with: String
  deprecationReason_ends_with: String
  deprecationReason_not_ends_with: String
  AND: [GqlEnumValueScalarWhereInput!]
  OR: [GqlEnumValueScalarWhereInput!]
  NOT: [GqlEnumValueScalarWhereInput!]
}

type GqlEnumValueSubscriptionPayload {
  mutation: MutationType!
  node: GqlEnumValue
  updatedFields: [String!]
  previousValues: GqlEnumValuePreviousValues
}

input GqlEnumValueSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GqlEnumValueWhereInput
  AND: [GqlEnumValueSubscriptionWhereInput!]
  OR: [GqlEnumValueSubscriptionWhereInput!]
  NOT: [GqlEnumValueSubscriptionWhereInput!]
}

input GqlEnumValueUpdateDataInput {
  name: String
  description: String
  isDeprecated: Boolean
  deprecationReason: String
}

input GqlEnumValueUpdateInput {
  name: String
  description: String
  isDeprecated: Boolean
  deprecationReason: String
}

input GqlEnumValueUpdateManyDataInput {
  name: String
  description: String
  isDeprecated: Boolean
  deprecationReason: String
}

input GqlEnumValueUpdateManyInput {
  create: [GqlEnumValueCreateInput!]
  update: [GqlEnumValueUpdateWithWhereUniqueNestedInput!]
  upsert: [GqlEnumValueUpsertWithWhereUniqueNestedInput!]
  delete: [GqlEnumValueWhereUniqueInput!]
  connect: [GqlEnumValueWhereUniqueInput!]
  set: [GqlEnumValueWhereUniqueInput!]
  disconnect: [GqlEnumValueWhereUniqueInput!]
  deleteMany: [GqlEnumValueScalarWhereInput!]
  updateMany: [GqlEnumValueUpdateManyWithWhereNestedInput!]
}

input GqlEnumValueUpdateManyMutationInput {
  name: String
  description: String
  isDeprecated: Boolean
  deprecationReason: String
}

input GqlEnumValueUpdateManyWithWhereNestedInput {
  where: GqlEnumValueScalarWhereInput!
  data: GqlEnumValueUpdateManyDataInput!
}

input GqlEnumValueUpdateWithWhereUniqueNestedInput {
  where: GqlEnumValueWhereUniqueInput!
  data: GqlEnumValueUpdateDataInput!
}

input GqlEnumValueUpsertWithWhereUniqueNestedInput {
  where: GqlEnumValueWhereUniqueInput!
  update: GqlEnumValueUpdateDataInput!
  create: GqlEnumValueCreateInput!
}

input GqlEnumValueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isDeprecated: Boolean
  isDeprecated_not: Boolean
  deprecationReason: String
  deprecationReason_not: String
  deprecationReason_in: [String!]
  deprecationReason_not_in: [String!]
  deprecationReason_lt: String
  deprecationReason_lte: String
  deprecationReason_gt: String
  deprecationReason_gte: String
  deprecationReason_contains: String
  deprecationReason_not_contains: String
  deprecationReason_starts_with: String
  deprecationReason_not_starts_with: String
  deprecationReason_ends_with: String
  deprecationReason_not_ends_with: String
  AND: [GqlEnumValueWhereInput!]
  OR: [GqlEnumValueWhereInput!]
  NOT: [GqlEnumValueWhereInput!]
}

input GqlEnumValueWhereUniqueInput {
  id: ID
}

type GqlField {
  id: ID!
  name: String!
  description: String
  typeName: String
  kinds: [GqlTypeKind!]!
  args(where: GqlInputValueWhereInput, orderBy: GqlInputValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlInputValue!]
  isDeprecated: Boolean!
  deprecationReason: String
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
}

type GqlFieldConnection {
  pageInfo: PageInfo!
  edges: [GqlFieldEdge]!
  aggregate: AggregateGqlField!
}

input GqlFieldCreateInput {
  id: ID
  name: String!
  description: String
  typeName: String
  kinds: GqlFieldCreatekindsInput
  args: GqlInputValueCreateManyInput
  isDeprecated: Boolean!
  deprecationReason: String
  comments: CommentCreateManyWithoutGqlFieldInput
}

input GqlFieldCreatekindsInput {
  set: [GqlTypeKind!]
}

input GqlFieldCreateManyInput {
  create: [GqlFieldCreateInput!]
  connect: [GqlFieldWhereUniqueInput!]
}

input GqlFieldCreateOneWithoutCommentsInput {
  create: GqlFieldCreateWithoutCommentsInput
  connect: GqlFieldWhereUniqueInput
}

input GqlFieldCreateWithoutCommentsInput {
  id: ID
  name: String!
  description: String
  typeName: String
  kinds: GqlFieldCreatekindsInput
  args: GqlInputValueCreateManyInput
  isDeprecated: Boolean!
  deprecationReason: String
}

type GqlFieldEdge {
  node: GqlField!
  cursor: String!
}

enum GqlFieldOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  typeName_ASC
  typeName_DESC
  isDeprecated_ASC
  isDeprecated_DESC
  deprecationReason_ASC
  deprecationReason_DESC
}

type GqlFieldPreviousValues {
  id: ID!
  name: String!
  description: String
  typeName: String
  kinds: [GqlTypeKind!]!
  isDeprecated: Boolean!
  deprecationReason: String
}

input GqlFieldScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  typeName: String
  typeName_not: String
  typeName_in: [String!]
  typeName_not_in: [String!]
  typeName_lt: String
  typeName_lte: String
  typeName_gt: String
  typeName_gte: String
  typeName_contains: String
  typeName_not_contains: String
  typeName_starts_with: String
  typeName_not_starts_with: String
  typeName_ends_with: String
  typeName_not_ends_with: String
  isDeprecated: Boolean
  isDeprecated_not: Boolean
  deprecationReason: String
  deprecationReason_not: String
  deprecationReason_in: [String!]
  deprecationReason_not_in: [String!]
  deprecationReason_lt: String
  deprecationReason_lte: String
  deprecationReason_gt: String
  deprecationReason_gte: String
  deprecationReason_contains: String
  deprecationReason_not_contains: String
  deprecationReason_starts_with: String
  deprecationReason_not_starts_with: String
  deprecationReason_ends_with: String
  deprecationReason_not_ends_with: String
  AND: [GqlFieldScalarWhereInput!]
  OR: [GqlFieldScalarWhereInput!]
  NOT: [GqlFieldScalarWhereInput!]
}

type GqlFieldSubscriptionPayload {
  mutation: MutationType!
  node: GqlField
  updatedFields: [String!]
  previousValues: GqlFieldPreviousValues
}

input GqlFieldSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GqlFieldWhereInput
  AND: [GqlFieldSubscriptionWhereInput!]
  OR: [GqlFieldSubscriptionWhereInput!]
  NOT: [GqlFieldSubscriptionWhereInput!]
}

input GqlFieldUpdateDataInput {
  name: String
  description: String
  typeName: String
  kinds: GqlFieldUpdatekindsInput
  args: GqlInputValueUpdateManyInput
  isDeprecated: Boolean
  deprecationReason: String
  comments: CommentUpdateManyWithoutGqlFieldInput
}

input GqlFieldUpdateInput {
  name: String
  description: String
  typeName: String
  kinds: GqlFieldUpdatekindsInput
  args: GqlInputValueUpdateManyInput
  isDeprecated: Boolean
  deprecationReason: String
  comments: CommentUpdateManyWithoutGqlFieldInput
}

input GqlFieldUpdatekindsInput {
  set: [GqlTypeKind!]
}

input GqlFieldUpdateManyDataInput {
  name: String
  description: String
  typeName: String
  kinds: GqlFieldUpdatekindsInput
  isDeprecated: Boolean
  deprecationReason: String
}

input GqlFieldUpdateManyInput {
  create: [GqlFieldCreateInput!]
  update: [GqlFieldUpdateWithWhereUniqueNestedInput!]
  upsert: [GqlFieldUpsertWithWhereUniqueNestedInput!]
  delete: [GqlFieldWhereUniqueInput!]
  connect: [GqlFieldWhereUniqueInput!]
  set: [GqlFieldWhereUniqueInput!]
  disconnect: [GqlFieldWhereUniqueInput!]
  deleteMany: [GqlFieldScalarWhereInput!]
  updateMany: [GqlFieldUpdateManyWithWhereNestedInput!]
}

input GqlFieldUpdateManyMutationInput {
  name: String
  description: String
  typeName: String
  kinds: GqlFieldUpdatekindsInput
  isDeprecated: Boolean
  deprecationReason: String
}

input GqlFieldUpdateManyWithWhereNestedInput {
  where: GqlFieldScalarWhereInput!
  data: GqlFieldUpdateManyDataInput!
}

input GqlFieldUpdateOneWithoutCommentsInput {
  create: GqlFieldCreateWithoutCommentsInput
  update: GqlFieldUpdateWithoutCommentsDataInput
  upsert: GqlFieldUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: GqlFieldWhereUniqueInput
}

input GqlFieldUpdateWithoutCommentsDataInput {
  name: String
  description: String
  typeName: String
  kinds: GqlFieldUpdatekindsInput
  args: GqlInputValueUpdateManyInput
  isDeprecated: Boolean
  deprecationReason: String
}

input GqlFieldUpdateWithWhereUniqueNestedInput {
  where: GqlFieldWhereUniqueInput!
  data: GqlFieldUpdateDataInput!
}

input GqlFieldUpsertWithoutCommentsInput {
  update: GqlFieldUpdateWithoutCommentsDataInput!
  create: GqlFieldCreateWithoutCommentsInput!
}

input GqlFieldUpsertWithWhereUniqueNestedInput {
  where: GqlFieldWhereUniqueInput!
  update: GqlFieldUpdateDataInput!
  create: GqlFieldCreateInput!
}

input GqlFieldWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  typeName: String
  typeName_not: String
  typeName_in: [String!]
  typeName_not_in: [String!]
  typeName_lt: String
  typeName_lte: String
  typeName_gt: String
  typeName_gte: String
  typeName_contains: String
  typeName_not_contains: String
  typeName_starts_with: String
  typeName_not_starts_with: String
  typeName_ends_with: String
  typeName_not_ends_with: String
  args_every: GqlInputValueWhereInput
  args_some: GqlInputValueWhereInput
  args_none: GqlInputValueWhereInput
  isDeprecated: Boolean
  isDeprecated_not: Boolean
  deprecationReason: String
  deprecationReason_not: String
  deprecationReason_in: [String!]
  deprecationReason_not_in: [String!]
  deprecationReason_lt: String
  deprecationReason_lte: String
  deprecationReason_gt: String
  deprecationReason_gte: String
  deprecationReason_contains: String
  deprecationReason_not_contains: String
  deprecationReason_starts_with: String
  deprecationReason_not_starts_with: String
  deprecationReason_ends_with: String
  deprecationReason_not_ends_with: String
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  AND: [GqlFieldWhereInput!]
  OR: [GqlFieldWhereInput!]
  NOT: [GqlFieldWhereInput!]
}

input GqlFieldWhereUniqueInput {
  id: ID
}

type GqlInputValue {
  id: ID!
  name: String!
  kinds: [GqlTypeKind!]!
  typeName: String
  description: String
  defaultValue: String
}

type GqlInputValueConnection {
  pageInfo: PageInfo!
  edges: [GqlInputValueEdge]!
  aggregate: AggregateGqlInputValue!
}

input GqlInputValueCreateInput {
  id: ID
  name: String!
  kinds: GqlInputValueCreatekindsInput
  typeName: String
  description: String
  defaultValue: String
}

input GqlInputValueCreatekindsInput {
  set: [GqlTypeKind!]
}

input GqlInputValueCreateManyInput {
  create: [GqlInputValueCreateInput!]
  connect: [GqlInputValueWhereUniqueInput!]
}

type GqlInputValueEdge {
  node: GqlInputValue!
  cursor: String!
}

enum GqlInputValueOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  typeName_ASC
  typeName_DESC
  description_ASC
  description_DESC
  defaultValue_ASC
  defaultValue_DESC
}

type GqlInputValuePreviousValues {
  id: ID!
  name: String!
  kinds: [GqlTypeKind!]!
  typeName: String
  description: String
  defaultValue: String
}

input GqlInputValueScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  typeName: String
  typeName_not: String
  typeName_in: [String!]
  typeName_not_in: [String!]
  typeName_lt: String
  typeName_lte: String
  typeName_gt: String
  typeName_gte: String
  typeName_contains: String
  typeName_not_contains: String
  typeName_starts_with: String
  typeName_not_starts_with: String
  typeName_ends_with: String
  typeName_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  defaultValue: String
  defaultValue_not: String
  defaultValue_in: [String!]
  defaultValue_not_in: [String!]
  defaultValue_lt: String
  defaultValue_lte: String
  defaultValue_gt: String
  defaultValue_gte: String
  defaultValue_contains: String
  defaultValue_not_contains: String
  defaultValue_starts_with: String
  defaultValue_not_starts_with: String
  defaultValue_ends_with: String
  defaultValue_not_ends_with: String
  AND: [GqlInputValueScalarWhereInput!]
  OR: [GqlInputValueScalarWhereInput!]
  NOT: [GqlInputValueScalarWhereInput!]
}

type GqlInputValueSubscriptionPayload {
  mutation: MutationType!
  node: GqlInputValue
  updatedFields: [String!]
  previousValues: GqlInputValuePreviousValues
}

input GqlInputValueSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GqlInputValueWhereInput
  AND: [GqlInputValueSubscriptionWhereInput!]
  OR: [GqlInputValueSubscriptionWhereInput!]
  NOT: [GqlInputValueSubscriptionWhereInput!]
}

input GqlInputValueUpdateDataInput {
  name: String
  kinds: GqlInputValueUpdatekindsInput
  typeName: String
  description: String
  defaultValue: String
}

input GqlInputValueUpdateInput {
  name: String
  kinds: GqlInputValueUpdatekindsInput
  typeName: String
  description: String
  defaultValue: String
}

input GqlInputValueUpdatekindsInput {
  set: [GqlTypeKind!]
}

input GqlInputValueUpdateManyDataInput {
  name: String
  kinds: GqlInputValueUpdatekindsInput
  typeName: String
  description: String
  defaultValue: String
}

input GqlInputValueUpdateManyInput {
  create: [GqlInputValueCreateInput!]
  update: [GqlInputValueUpdateWithWhereUniqueNestedInput!]
  upsert: [GqlInputValueUpsertWithWhereUniqueNestedInput!]
  delete: [GqlInputValueWhereUniqueInput!]
  connect: [GqlInputValueWhereUniqueInput!]
  set: [GqlInputValueWhereUniqueInput!]
  disconnect: [GqlInputValueWhereUniqueInput!]
  deleteMany: [GqlInputValueScalarWhereInput!]
  updateMany: [GqlInputValueUpdateManyWithWhereNestedInput!]
}

input GqlInputValueUpdateManyMutationInput {
  name: String
  kinds: GqlInputValueUpdatekindsInput
  typeName: String
  description: String
  defaultValue: String
}

input GqlInputValueUpdateManyWithWhereNestedInput {
  where: GqlInputValueScalarWhereInput!
  data: GqlInputValueUpdateManyDataInput!
}

input GqlInputValueUpdateWithWhereUniqueNestedInput {
  where: GqlInputValueWhereUniqueInput!
  data: GqlInputValueUpdateDataInput!
}

input GqlInputValueUpsertWithWhereUniqueNestedInput {
  where: GqlInputValueWhereUniqueInput!
  update: GqlInputValueUpdateDataInput!
  create: GqlInputValueCreateInput!
}

input GqlInputValueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  typeName: String
  typeName_not: String
  typeName_in: [String!]
  typeName_not_in: [String!]
  typeName_lt: String
  typeName_lte: String
  typeName_gt: String
  typeName_gte: String
  typeName_contains: String
  typeName_not_contains: String
  typeName_starts_with: String
  typeName_not_starts_with: String
  typeName_ends_with: String
  typeName_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  defaultValue: String
  defaultValue_not: String
  defaultValue_in: [String!]
  defaultValue_not_in: [String!]
  defaultValue_lt: String
  defaultValue_lte: String
  defaultValue_gt: String
  defaultValue_gte: String
  defaultValue_contains: String
  defaultValue_not_contains: String
  defaultValue_starts_with: String
  defaultValue_not_starts_with: String
  defaultValue_ends_with: String
  defaultValue_not_ends_with: String
  AND: [GqlInputValueWhereInput!]
  OR: [GqlInputValueWhereInput!]
  NOT: [GqlInputValueWhereInput!]
}

input GqlInputValueWhereUniqueInput {
  id: ID
}

type GqlIntrospectionSchema {
  id: ID!
  name: String!
  types(where: GqlTypeWhereInput, orderBy: GqlTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlType!]
  directives(where: GqlDirectiveWhereInput, orderBy: GqlDirectiveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlDirective!]
}

type GqlIntrospectionSchemaConnection {
  pageInfo: PageInfo!
  edges: [GqlIntrospectionSchemaEdge]!
  aggregate: AggregateGqlIntrospectionSchema!
}

input GqlIntrospectionSchemaCreateInput {
  id: ID
  name: String
  types: GqlTypeCreateManyWithoutSchemaInput
  directives: GqlDirectiveCreateManyInput
}

input GqlIntrospectionSchemaCreateOneInput {
  create: GqlIntrospectionSchemaCreateInput
  connect: GqlIntrospectionSchemaWhereUniqueInput
}

input GqlIntrospectionSchemaCreateOneWithoutTypesInput {
  create: GqlIntrospectionSchemaCreateWithoutTypesInput
  connect: GqlIntrospectionSchemaWhereUniqueInput
}

input GqlIntrospectionSchemaCreateWithoutTypesInput {
  id: ID
  name: String
  directives: GqlDirectiveCreateManyInput
}

type GqlIntrospectionSchemaEdge {
  node: GqlIntrospectionSchema!
  cursor: String!
}

enum GqlIntrospectionSchemaOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type GqlIntrospectionSchemaPreviousValues {
  id: ID!
  name: String!
}

type GqlIntrospectionSchemaSubscriptionPayload {
  mutation: MutationType!
  node: GqlIntrospectionSchema
  updatedFields: [String!]
  previousValues: GqlIntrospectionSchemaPreviousValues
}

input GqlIntrospectionSchemaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GqlIntrospectionSchemaWhereInput
  AND: [GqlIntrospectionSchemaSubscriptionWhereInput!]
  OR: [GqlIntrospectionSchemaSubscriptionWhereInput!]
  NOT: [GqlIntrospectionSchemaSubscriptionWhereInput!]
}

input GqlIntrospectionSchemaUpdateDataInput {
  name: String
  types: GqlTypeUpdateManyWithoutSchemaInput
  directives: GqlDirectiveUpdateManyInput
}

input GqlIntrospectionSchemaUpdateInput {
  name: String
  types: GqlTypeUpdateManyWithoutSchemaInput
  directives: GqlDirectiveUpdateManyInput
}

input GqlIntrospectionSchemaUpdateManyMutationInput {
  name: String
}

input GqlIntrospectionSchemaUpdateOneInput {
  create: GqlIntrospectionSchemaCreateInput
  update: GqlIntrospectionSchemaUpdateDataInput
  upsert: GqlIntrospectionSchemaUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GqlIntrospectionSchemaWhereUniqueInput
}

input GqlIntrospectionSchemaUpdateOneRequiredWithoutTypesInput {
  create: GqlIntrospectionSchemaCreateWithoutTypesInput
  update: GqlIntrospectionSchemaUpdateWithoutTypesDataInput
  upsert: GqlIntrospectionSchemaUpsertWithoutTypesInput
  connect: GqlIntrospectionSchemaWhereUniqueInput
}

input GqlIntrospectionSchemaUpdateWithoutTypesDataInput {
  name: String
  directives: GqlDirectiveUpdateManyInput
}

input GqlIntrospectionSchemaUpsertNestedInput {
  update: GqlIntrospectionSchemaUpdateDataInput!
  create: GqlIntrospectionSchemaCreateInput!
}

input GqlIntrospectionSchemaUpsertWithoutTypesInput {
  update: GqlIntrospectionSchemaUpdateWithoutTypesDataInput!
  create: GqlIntrospectionSchemaCreateWithoutTypesInput!
}

input GqlIntrospectionSchemaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  types_every: GqlTypeWhereInput
  types_some: GqlTypeWhereInput
  types_none: GqlTypeWhereInput
  directives_every: GqlDirectiveWhereInput
  directives_some: GqlDirectiveWhereInput
  directives_none: GqlDirectiveWhereInput
  AND: [GqlIntrospectionSchemaWhereInput!]
  OR: [GqlIntrospectionSchemaWhereInput!]
  NOT: [GqlIntrospectionSchemaWhereInput!]
}

input GqlIntrospectionSchemaWhereUniqueInput {
  id: ID
}

type GqlSchema {
  id: ID!
  name: String!
  owner: User
  members(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  apiKey: String!
  introspectionSchema: GqlIntrospectionSchema
  endpointUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GqlSchemaConnection {
  pageInfo: PageInfo!
  edges: [GqlSchemaEdge]!
  aggregate: AggregateGqlSchema!
}

input GqlSchemaCreateInput {
  id: ID
  name: String!
  owner: UserCreateOneInput
  members: UserCreateManyWithoutSchemasInput
  apiKey: String!
  introspectionSchema: GqlIntrospectionSchemaCreateOneInput
  endpointUrl: String
}

input GqlSchemaCreateManyWithoutMembersInput {
  create: [GqlSchemaCreateWithoutMembersInput!]
  connect: [GqlSchemaWhereUniqueInput!]
}

input GqlSchemaCreateWithoutMembersInput {
  id: ID
  name: String!
  owner: UserCreateOneInput
  apiKey: String!
  introspectionSchema: GqlIntrospectionSchemaCreateOneInput
  endpointUrl: String
}

type GqlSchemaEdge {
  node: GqlSchema!
  cursor: String!
}

enum GqlSchemaOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  apiKey_ASC
  apiKey_DESC
  endpointUrl_ASC
  endpointUrl_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GqlSchemaPreviousValues {
  id: ID!
  name: String!
  apiKey: String!
  endpointUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input GqlSchemaScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  apiKey: String
  apiKey_not: String
  apiKey_in: [String!]
  apiKey_not_in: [String!]
  apiKey_lt: String
  apiKey_lte: String
  apiKey_gt: String
  apiKey_gte: String
  apiKey_contains: String
  apiKey_not_contains: String
  apiKey_starts_with: String
  apiKey_not_starts_with: String
  apiKey_ends_with: String
  apiKey_not_ends_with: String
  endpointUrl: String
  endpointUrl_not: String
  endpointUrl_in: [String!]
  endpointUrl_not_in: [String!]
  endpointUrl_lt: String
  endpointUrl_lte: String
  endpointUrl_gt: String
  endpointUrl_gte: String
  endpointUrl_contains: String
  endpointUrl_not_contains: String
  endpointUrl_starts_with: String
  endpointUrl_not_starts_with: String
  endpointUrl_ends_with: String
  endpointUrl_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [GqlSchemaScalarWhereInput!]
  OR: [GqlSchemaScalarWhereInput!]
  NOT: [GqlSchemaScalarWhereInput!]
}

type GqlSchemaSubscriptionPayload {
  mutation: MutationType!
  node: GqlSchema
  updatedFields: [String!]
  previousValues: GqlSchemaPreviousValues
}

input GqlSchemaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GqlSchemaWhereInput
  AND: [GqlSchemaSubscriptionWhereInput!]
  OR: [GqlSchemaSubscriptionWhereInput!]
  NOT: [GqlSchemaSubscriptionWhereInput!]
}

input GqlSchemaUpdateInput {
  name: String
  owner: UserUpdateOneInput
  members: UserUpdateManyWithoutSchemasInput
  apiKey: String
  introspectionSchema: GqlIntrospectionSchemaUpdateOneInput
  endpointUrl: String
}

input GqlSchemaUpdateManyDataInput {
  name: String
  apiKey: String
  endpointUrl: String
}

input GqlSchemaUpdateManyMutationInput {
  name: String
  apiKey: String
  endpointUrl: String
}

input GqlSchemaUpdateManyWithoutMembersInput {
  create: [GqlSchemaCreateWithoutMembersInput!]
  delete: [GqlSchemaWhereUniqueInput!]
  connect: [GqlSchemaWhereUniqueInput!]
  set: [GqlSchemaWhereUniqueInput!]
  disconnect: [GqlSchemaWhereUniqueInput!]
  update: [GqlSchemaUpdateWithWhereUniqueWithoutMembersInput!]
  upsert: [GqlSchemaUpsertWithWhereUniqueWithoutMembersInput!]
  deleteMany: [GqlSchemaScalarWhereInput!]
  updateMany: [GqlSchemaUpdateManyWithWhereNestedInput!]
}

input GqlSchemaUpdateManyWithWhereNestedInput {
  where: GqlSchemaScalarWhereInput!
  data: GqlSchemaUpdateManyDataInput!
}

input GqlSchemaUpdateWithoutMembersDataInput {
  name: String
  owner: UserUpdateOneInput
  apiKey: String
  introspectionSchema: GqlIntrospectionSchemaUpdateOneInput
  endpointUrl: String
}

input GqlSchemaUpdateWithWhereUniqueWithoutMembersInput {
  where: GqlSchemaWhereUniqueInput!
  data: GqlSchemaUpdateWithoutMembersDataInput!
}

input GqlSchemaUpsertWithWhereUniqueWithoutMembersInput {
  where: GqlSchemaWhereUniqueInput!
  update: GqlSchemaUpdateWithoutMembersDataInput!
  create: GqlSchemaCreateWithoutMembersInput!
}

input GqlSchemaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  owner: UserWhereInput
  members_every: UserWhereInput
  members_some: UserWhereInput
  members_none: UserWhereInput
  apiKey: String
  apiKey_not: String
  apiKey_in: [String!]
  apiKey_not_in: [String!]
  apiKey_lt: String
  apiKey_lte: String
  apiKey_gt: String
  apiKey_gte: String
  apiKey_contains: String
  apiKey_not_contains: String
  apiKey_starts_with: String
  apiKey_not_starts_with: String
  apiKey_ends_with: String
  apiKey_not_ends_with: String
  introspectionSchema: GqlIntrospectionSchemaWhereInput
  endpointUrl: String
  endpointUrl_not: String
  endpointUrl_in: [String!]
  endpointUrl_not_in: [String!]
  endpointUrl_lt: String
  endpointUrl_lte: String
  endpointUrl_gt: String
  endpointUrl_gte: String
  endpointUrl_contains: String
  endpointUrl_not_contains: String
  endpointUrl_starts_with: String
  endpointUrl_not_starts_with: String
  endpointUrl_ends_with: String
  endpointUrl_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [GqlSchemaWhereInput!]
  OR: [GqlSchemaWhereInput!]
  NOT: [GqlSchemaWhereInput!]
}

input GqlSchemaWhereUniqueInput {
  id: ID
}

type GqlType {
  id: ID!
  kind: GqlTypeKind!
  name: String
  description: String
  schema: GqlIntrospectionSchema!
  fields(where: GqlFieldWhereInput, orderBy: GqlFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlField!]
  interfaces(where: GqlBaseTypeWhereInput, orderBy: GqlBaseTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlBaseType!]
  possibleTypes(where: GqlBaseTypeWhereInput, orderBy: GqlBaseTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlBaseType!]
  enumValues(where: GqlEnumValueWhereInput, orderBy: GqlEnumValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlEnumValue!]
  inputFields(where: GqlInputValueWhereInput, orderBy: GqlInputValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlInputValue!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
}

type GqlTypeConnection {
  pageInfo: PageInfo!
  edges: [GqlTypeEdge]!
  aggregate: AggregateGqlType!
}

input GqlTypeCreateInput {
  id: ID
  kind: GqlTypeKind!
  name: String
  description: String
  schema: GqlIntrospectionSchemaCreateOneWithoutTypesInput!
  fields: GqlFieldCreateManyInput
  interfaces: GqlBaseTypeCreateManyInput
  possibleTypes: GqlBaseTypeCreateManyInput
  enumValues: GqlEnumValueCreateManyInput
  inputFields: GqlInputValueCreateManyInput
  comments: CommentCreateManyWithoutGqlTypeInput
}

input GqlTypeCreateManyWithoutSchemaInput {
  create: [GqlTypeCreateWithoutSchemaInput!]
  connect: [GqlTypeWhereUniqueInput!]
}

input GqlTypeCreateOneWithoutCommentsInput {
  create: GqlTypeCreateWithoutCommentsInput
  connect: GqlTypeWhereUniqueInput
}

input GqlTypeCreateWithoutCommentsInput {
  id: ID
  kind: GqlTypeKind!
  name: String
  description: String
  schema: GqlIntrospectionSchemaCreateOneWithoutTypesInput!
  fields: GqlFieldCreateManyInput
  interfaces: GqlBaseTypeCreateManyInput
  possibleTypes: GqlBaseTypeCreateManyInput
  enumValues: GqlEnumValueCreateManyInput
  inputFields: GqlInputValueCreateManyInput
}

input GqlTypeCreateWithoutSchemaInput {
  id: ID
  kind: GqlTypeKind!
  name: String
  description: String
  fields: GqlFieldCreateManyInput
  interfaces: GqlBaseTypeCreateManyInput
  possibleTypes: GqlBaseTypeCreateManyInput
  enumValues: GqlEnumValueCreateManyInput
  inputFields: GqlInputValueCreateManyInput
  comments: CommentCreateManyWithoutGqlTypeInput
}

type GqlTypeEdge {
  node: GqlType!
  cursor: String!
}

enum GqlTypeKind {
  SCALAR
  OBJECT
  INTERFACE
  UNION
  ENUM
  INPUT_OBJECT
  LIST
  NON_NULL
}

enum GqlTypeOrderByInput {
  id_ASC
  id_DESC
  kind_ASC
  kind_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
}

type GqlTypePreviousValues {
  id: ID!
  kind: GqlTypeKind!
  name: String
  description: String
}

input GqlTypeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  kind: GqlTypeKind
  kind_not: GqlTypeKind
  kind_in: [GqlTypeKind!]
  kind_not_in: [GqlTypeKind!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [GqlTypeScalarWhereInput!]
  OR: [GqlTypeScalarWhereInput!]
  NOT: [GqlTypeScalarWhereInput!]
}

type GqlTypeSubscriptionPayload {
  mutation: MutationType!
  node: GqlType
  updatedFields: [String!]
  previousValues: GqlTypePreviousValues
}

input GqlTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GqlTypeWhereInput
  AND: [GqlTypeSubscriptionWhereInput!]
  OR: [GqlTypeSubscriptionWhereInput!]
  NOT: [GqlTypeSubscriptionWhereInput!]
}

input GqlTypeUpdateInput {
  kind: GqlTypeKind
  name: String
  description: String
  schema: GqlIntrospectionSchemaUpdateOneRequiredWithoutTypesInput
  fields: GqlFieldUpdateManyInput
  interfaces: GqlBaseTypeUpdateManyInput
  possibleTypes: GqlBaseTypeUpdateManyInput
  enumValues: GqlEnumValueUpdateManyInput
  inputFields: GqlInputValueUpdateManyInput
  comments: CommentUpdateManyWithoutGqlTypeInput
}

input GqlTypeUpdateManyDataInput {
  kind: GqlTypeKind
  name: String
  description: String
}

input GqlTypeUpdateManyMutationInput {
  kind: GqlTypeKind
  name: String
  description: String
}

input GqlTypeUpdateManyWithoutSchemaInput {
  create: [GqlTypeCreateWithoutSchemaInput!]
  delete: [GqlTypeWhereUniqueInput!]
  connect: [GqlTypeWhereUniqueInput!]
  set: [GqlTypeWhereUniqueInput!]
  disconnect: [GqlTypeWhereUniqueInput!]
  update: [GqlTypeUpdateWithWhereUniqueWithoutSchemaInput!]
  upsert: [GqlTypeUpsertWithWhereUniqueWithoutSchemaInput!]
  deleteMany: [GqlTypeScalarWhereInput!]
  updateMany: [GqlTypeUpdateManyWithWhereNestedInput!]
}

input GqlTypeUpdateManyWithWhereNestedInput {
  where: GqlTypeScalarWhereInput!
  data: GqlTypeUpdateManyDataInput!
}

input GqlTypeUpdateOneWithoutCommentsInput {
  create: GqlTypeCreateWithoutCommentsInput
  update: GqlTypeUpdateWithoutCommentsDataInput
  upsert: GqlTypeUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: GqlTypeWhereUniqueInput
}

input GqlTypeUpdateWithoutCommentsDataInput {
  kind: GqlTypeKind
  name: String
  description: String
  schema: GqlIntrospectionSchemaUpdateOneRequiredWithoutTypesInput
  fields: GqlFieldUpdateManyInput
  interfaces: GqlBaseTypeUpdateManyInput
  possibleTypes: GqlBaseTypeUpdateManyInput
  enumValues: GqlEnumValueUpdateManyInput
  inputFields: GqlInputValueUpdateManyInput
}

input GqlTypeUpdateWithoutSchemaDataInput {
  kind: GqlTypeKind
  name: String
  description: String
  fields: GqlFieldUpdateManyInput
  interfaces: GqlBaseTypeUpdateManyInput
  possibleTypes: GqlBaseTypeUpdateManyInput
  enumValues: GqlEnumValueUpdateManyInput
  inputFields: GqlInputValueUpdateManyInput
  comments: CommentUpdateManyWithoutGqlTypeInput
}

input GqlTypeUpdateWithWhereUniqueWithoutSchemaInput {
  where: GqlTypeWhereUniqueInput!
  data: GqlTypeUpdateWithoutSchemaDataInput!
}

input GqlTypeUpsertWithoutCommentsInput {
  update: GqlTypeUpdateWithoutCommentsDataInput!
  create: GqlTypeCreateWithoutCommentsInput!
}

input GqlTypeUpsertWithWhereUniqueWithoutSchemaInput {
  where: GqlTypeWhereUniqueInput!
  update: GqlTypeUpdateWithoutSchemaDataInput!
  create: GqlTypeCreateWithoutSchemaInput!
}

input GqlTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  kind: GqlTypeKind
  kind_not: GqlTypeKind
  kind_in: [GqlTypeKind!]
  kind_not_in: [GqlTypeKind!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  schema: GqlIntrospectionSchemaWhereInput
  fields_every: GqlFieldWhereInput
  fields_some: GqlFieldWhereInput
  fields_none: GqlFieldWhereInput
  interfaces_every: GqlBaseTypeWhereInput
  interfaces_some: GqlBaseTypeWhereInput
  interfaces_none: GqlBaseTypeWhereInput
  possibleTypes_every: GqlBaseTypeWhereInput
  possibleTypes_some: GqlBaseTypeWhereInput
  possibleTypes_none: GqlBaseTypeWhereInput
  enumValues_every: GqlEnumValueWhereInput
  enumValues_some: GqlEnumValueWhereInput
  enumValues_none: GqlEnumValueWhereInput
  inputFields_every: GqlInputValueWhereInput
  inputFields_some: GqlInputValueWhereInput
  inputFields_none: GqlInputValueWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  AND: [GqlTypeWhereInput!]
  OR: [GqlTypeWhereInput!]
  NOT: [GqlTypeWhereInput!]
}

input GqlTypeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createCommentContent(data: CommentContentCreateInput!): CommentContent!
  updateCommentContent(data: CommentContentUpdateInput!, where: CommentContentWhereUniqueInput!): CommentContent
  updateManyCommentContents(data: CommentContentUpdateManyMutationInput!, where: CommentContentWhereInput): BatchPayload!
  upsertCommentContent(where: CommentContentWhereUniqueInput!, create: CommentContentCreateInput!, update: CommentContentUpdateInput!): CommentContent!
  deleteCommentContent(where: CommentContentWhereUniqueInput!): CommentContent
  deleteManyCommentContents(where: CommentContentWhereInput): BatchPayload!
  createGqlBaseType(data: GqlBaseTypeCreateInput!): GqlBaseType!
  updateGqlBaseType(data: GqlBaseTypeUpdateInput!, where: GqlBaseTypeWhereUniqueInput!): GqlBaseType
  updateManyGqlBaseTypes(data: GqlBaseTypeUpdateManyMutationInput!, where: GqlBaseTypeWhereInput): BatchPayload!
  upsertGqlBaseType(where: GqlBaseTypeWhereUniqueInput!, create: GqlBaseTypeCreateInput!, update: GqlBaseTypeUpdateInput!): GqlBaseType!
  deleteGqlBaseType(where: GqlBaseTypeWhereUniqueInput!): GqlBaseType
  deleteManyGqlBaseTypes(where: GqlBaseTypeWhereInput): BatchPayload!
  createGqlDirective(data: GqlDirectiveCreateInput!): GqlDirective!
  updateGqlDirective(data: GqlDirectiveUpdateInput!, where: GqlDirectiveWhereUniqueInput!): GqlDirective
  updateManyGqlDirectives(data: GqlDirectiveUpdateManyMutationInput!, where: GqlDirectiveWhereInput): BatchPayload!
  upsertGqlDirective(where: GqlDirectiveWhereUniqueInput!, create: GqlDirectiveCreateInput!, update: GqlDirectiveUpdateInput!): GqlDirective!
  deleteGqlDirective(where: GqlDirectiveWhereUniqueInput!): GqlDirective
  deleteManyGqlDirectives(where: GqlDirectiveWhereInput): BatchPayload!
  createGqlEnumValue(data: GqlEnumValueCreateInput!): GqlEnumValue!
  updateGqlEnumValue(data: GqlEnumValueUpdateInput!, where: GqlEnumValueWhereUniqueInput!): GqlEnumValue
  updateManyGqlEnumValues(data: GqlEnumValueUpdateManyMutationInput!, where: GqlEnumValueWhereInput): BatchPayload!
  upsertGqlEnumValue(where: GqlEnumValueWhereUniqueInput!, create: GqlEnumValueCreateInput!, update: GqlEnumValueUpdateInput!): GqlEnumValue!
  deleteGqlEnumValue(where: GqlEnumValueWhereUniqueInput!): GqlEnumValue
  deleteManyGqlEnumValues(where: GqlEnumValueWhereInput): BatchPayload!
  createGqlField(data: GqlFieldCreateInput!): GqlField!
  updateGqlField(data: GqlFieldUpdateInput!, where: GqlFieldWhereUniqueInput!): GqlField
  updateManyGqlFields(data: GqlFieldUpdateManyMutationInput!, where: GqlFieldWhereInput): BatchPayload!
  upsertGqlField(where: GqlFieldWhereUniqueInput!, create: GqlFieldCreateInput!, update: GqlFieldUpdateInput!): GqlField!
  deleteGqlField(where: GqlFieldWhereUniqueInput!): GqlField
  deleteManyGqlFields(where: GqlFieldWhereInput): BatchPayload!
  createGqlInputValue(data: GqlInputValueCreateInput!): GqlInputValue!
  updateGqlInputValue(data: GqlInputValueUpdateInput!, where: GqlInputValueWhereUniqueInput!): GqlInputValue
  updateManyGqlInputValues(data: GqlInputValueUpdateManyMutationInput!, where: GqlInputValueWhereInput): BatchPayload!
  upsertGqlInputValue(where: GqlInputValueWhereUniqueInput!, create: GqlInputValueCreateInput!, update: GqlInputValueUpdateInput!): GqlInputValue!
  deleteGqlInputValue(where: GqlInputValueWhereUniqueInput!): GqlInputValue
  deleteManyGqlInputValues(where: GqlInputValueWhereInput): BatchPayload!
  createGqlIntrospectionSchema(data: GqlIntrospectionSchemaCreateInput!): GqlIntrospectionSchema!
  updateGqlIntrospectionSchema(data: GqlIntrospectionSchemaUpdateInput!, where: GqlIntrospectionSchemaWhereUniqueInput!): GqlIntrospectionSchema
  updateManyGqlIntrospectionSchemas(data: GqlIntrospectionSchemaUpdateManyMutationInput!, where: GqlIntrospectionSchemaWhereInput): BatchPayload!
  upsertGqlIntrospectionSchema(where: GqlIntrospectionSchemaWhereUniqueInput!, create: GqlIntrospectionSchemaCreateInput!, update: GqlIntrospectionSchemaUpdateInput!): GqlIntrospectionSchema!
  deleteGqlIntrospectionSchema(where: GqlIntrospectionSchemaWhereUniqueInput!): GqlIntrospectionSchema
  deleteManyGqlIntrospectionSchemas(where: GqlIntrospectionSchemaWhereInput): BatchPayload!
  createGqlSchema(data: GqlSchemaCreateInput!): GqlSchema!
  updateGqlSchema(data: GqlSchemaUpdateInput!, where: GqlSchemaWhereUniqueInput!): GqlSchema
  updateManyGqlSchemas(data: GqlSchemaUpdateManyMutationInput!, where: GqlSchemaWhereInput): BatchPayload!
  upsertGqlSchema(where: GqlSchemaWhereUniqueInput!, create: GqlSchemaCreateInput!, update: GqlSchemaUpdateInput!): GqlSchema!
  deleteGqlSchema(where: GqlSchemaWhereUniqueInput!): GqlSchema
  deleteManyGqlSchemas(where: GqlSchemaWhereInput): BatchPayload!
  createGqlType(data: GqlTypeCreateInput!): GqlType!
  updateGqlType(data: GqlTypeUpdateInput!, where: GqlTypeWhereUniqueInput!): GqlType
  updateManyGqlTypes(data: GqlTypeUpdateManyMutationInput!, where: GqlTypeWhereInput): BatchPayload!
  upsertGqlType(where: GqlTypeWhereUniqueInput!, create: GqlTypeCreateInput!, update: GqlTypeUpdateInput!): GqlType!
  deleteGqlType(where: GqlTypeWhereUniqueInput!): GqlType
  deleteManyGqlTypes(where: GqlTypeWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createUserProfile(data: UserProfileCreateInput!): UserProfile!
  updateUserProfile(data: UserProfileUpdateInput!, where: UserProfileWhereUniqueInput!): UserProfile
  updateManyUserProfiles(data: UserProfileUpdateManyMutationInput!, where: UserProfileWhereInput): BatchPayload!
  upsertUserProfile(where: UserProfileWhereUniqueInput!, create: UserProfileCreateInput!, update: UserProfileUpdateInput!): UserProfile!
  deleteUserProfile(where: UserProfileWhereUniqueInput!): UserProfile
  deleteManyUserProfiles(where: UserProfileWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  commentContent(where: CommentContentWhereUniqueInput!): CommentContent
  commentContents(where: CommentContentWhereInput, orderBy: CommentContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CommentContent]!
  commentContentsConnection(where: CommentContentWhereInput, orderBy: CommentContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentContentConnection!
  gqlBaseType(where: GqlBaseTypeWhereUniqueInput!): GqlBaseType
  gqlBaseTypes(where: GqlBaseTypeWhereInput, orderBy: GqlBaseTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlBaseType]!
  gqlBaseTypesConnection(where: GqlBaseTypeWhereInput, orderBy: GqlBaseTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GqlBaseTypeConnection!
  gqlDirective(where: GqlDirectiveWhereUniqueInput!): GqlDirective
  gqlDirectives(where: GqlDirectiveWhereInput, orderBy: GqlDirectiveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlDirective]!
  gqlDirectivesConnection(where: GqlDirectiveWhereInput, orderBy: GqlDirectiveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GqlDirectiveConnection!
  gqlEnumValue(where: GqlEnumValueWhereUniqueInput!): GqlEnumValue
  gqlEnumValues(where: GqlEnumValueWhereInput, orderBy: GqlEnumValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlEnumValue]!
  gqlEnumValuesConnection(where: GqlEnumValueWhereInput, orderBy: GqlEnumValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GqlEnumValueConnection!
  gqlField(where: GqlFieldWhereUniqueInput!): GqlField
  gqlFields(where: GqlFieldWhereInput, orderBy: GqlFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlField]!
  gqlFieldsConnection(where: GqlFieldWhereInput, orderBy: GqlFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GqlFieldConnection!
  gqlInputValue(where: GqlInputValueWhereUniqueInput!): GqlInputValue
  gqlInputValues(where: GqlInputValueWhereInput, orderBy: GqlInputValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlInputValue]!
  gqlInputValuesConnection(where: GqlInputValueWhereInput, orderBy: GqlInputValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GqlInputValueConnection!
  gqlIntrospectionSchema(where: GqlIntrospectionSchemaWhereUniqueInput!): GqlIntrospectionSchema
  gqlIntrospectionSchemas(where: GqlIntrospectionSchemaWhereInput, orderBy: GqlIntrospectionSchemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlIntrospectionSchema]!
  gqlIntrospectionSchemasConnection(where: GqlIntrospectionSchemaWhereInput, orderBy: GqlIntrospectionSchemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GqlIntrospectionSchemaConnection!
  gqlSchema(where: GqlSchemaWhereUniqueInput!): GqlSchema
  gqlSchemas(where: GqlSchemaWhereInput, orderBy: GqlSchemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlSchema]!
  gqlSchemasConnection(where: GqlSchemaWhereInput, orderBy: GqlSchemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GqlSchemaConnection!
  gqlType(where: GqlTypeWhereUniqueInput!): GqlType
  gqlTypes(where: GqlTypeWhereInput, orderBy: GqlTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlType]!
  gqlTypesConnection(where: GqlTypeWhereInput, orderBy: GqlTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GqlTypeConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  userProfile(where: UserProfileWhereUniqueInput!): UserProfile
  userProfiles(where: UserProfileWhereInput, orderBy: UserProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserProfile]!
  userProfilesConnection(where: UserProfileWhereInput, orderBy: UserProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserProfileConnection!
  node(id: ID!): Node
}

type Subscription {
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  commentContent(where: CommentContentSubscriptionWhereInput): CommentContentSubscriptionPayload
  gqlBaseType(where: GqlBaseTypeSubscriptionWhereInput): GqlBaseTypeSubscriptionPayload
  gqlDirective(where: GqlDirectiveSubscriptionWhereInput): GqlDirectiveSubscriptionPayload
  gqlEnumValue(where: GqlEnumValueSubscriptionWhereInput): GqlEnumValueSubscriptionPayload
  gqlField(where: GqlFieldSubscriptionWhereInput): GqlFieldSubscriptionPayload
  gqlInputValue(where: GqlInputValueSubscriptionWhereInput): GqlInputValueSubscriptionPayload
  gqlIntrospectionSchema(where: GqlIntrospectionSchemaSubscriptionWhereInput): GqlIntrospectionSchemaSubscriptionPayload
  gqlSchema(where: GqlSchemaSubscriptionWhereInput): GqlSchemaSubscriptionPayload
  gqlType(where: GqlTypeSubscriptionWhereInput): GqlTypeSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  userProfile(where: UserProfileSubscriptionWhereInput): UserProfileSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  username: String!
  password: String!
  profile: UserProfile
  schemas(where: GqlSchemaWhereInput, orderBy: GqlSchemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GqlSchema!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  username: String!
  password: String!
  profile: UserProfileCreateOneInput
  schemas: GqlSchemaCreateManyWithoutMembersInput
}

input UserCreateManyWithoutSchemasInput {
  create: [UserCreateWithoutSchemasInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutSchemasInput {
  id: ID
  email: String!
  username: String!
  password: String!
  profile: UserProfileCreateOneInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  username: String!
  password: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserProfile {
  id: ID!
  firstName: String
  lastName: String
  fullName: String
  picture: String
}

type UserProfileConnection {
  pageInfo: PageInfo!
  edges: [UserProfileEdge]!
  aggregate: AggregateUserProfile!
}

input UserProfileCreateInput {
  id: ID
  firstName: String
  lastName: String
  fullName: String
  picture: String
}

input UserProfileCreateOneInput {
  create: UserProfileCreateInput
  connect: UserProfileWhereUniqueInput
}

type UserProfileEdge {
  node: UserProfile!
  cursor: String!
}

enum UserProfileOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  fullName_ASC
  fullName_DESC
  picture_ASC
  picture_DESC
}

type UserProfilePreviousValues {
  id: ID!
  firstName: String
  lastName: String
  fullName: String
  picture: String
}

type UserProfileSubscriptionPayload {
  mutation: MutationType!
  node: UserProfile
  updatedFields: [String!]
  previousValues: UserProfilePreviousValues
}

input UserProfileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserProfileWhereInput
  AND: [UserProfileSubscriptionWhereInput!]
  OR: [UserProfileSubscriptionWhereInput!]
  NOT: [UserProfileSubscriptionWhereInput!]
}

input UserProfileUpdateDataInput {
  firstName: String
  lastName: String
  fullName: String
  picture: String
}

input UserProfileUpdateInput {
  firstName: String
  lastName: String
  fullName: String
  picture: String
}

input UserProfileUpdateManyMutationInput {
  firstName: String
  lastName: String
  fullName: String
  picture: String
}

input UserProfileUpdateOneInput {
  create: UserProfileCreateInput
  update: UserProfileUpdateDataInput
  upsert: UserProfileUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserProfileWhereUniqueInput
}

input UserProfileUpsertNestedInput {
  update: UserProfileUpdateDataInput!
  create: UserProfileCreateInput!
}

input UserProfileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  picture: String
  picture_not: String
  picture_in: [String!]
  picture_not_in: [String!]
  picture_lt: String
  picture_lte: String
  picture_gt: String
  picture_gte: String
  picture_contains: String
  picture_not_contains: String
  picture_starts_with: String
  picture_not_starts_with: String
  picture_ends_with: String
  picture_not_ends_with: String
  AND: [UserProfileWhereInput!]
  OR: [UserProfileWhereInput!]
  NOT: [UserProfileWhereInput!]
}

input UserProfileWhereUniqueInput {
  id: ID
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  username: String
  password: String
  profile: UserProfileUpdateOneInput
  schemas: GqlSchemaUpdateManyWithoutMembersInput
}

input UserUpdateInput {
  email: String
  username: String
  password: String
  profile: UserProfileUpdateOneInput
  schemas: GqlSchemaUpdateManyWithoutMembersInput
}

input UserUpdateManyDataInput {
  email: String
  username: String
  password: String
}

input UserUpdateManyMutationInput {
  email: String
  username: String
  password: String
}

input UserUpdateManyWithoutSchemasInput {
  create: [UserCreateWithoutSchemasInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutSchemasInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutSchemasInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutSchemasDataInput {
  email: String
  username: String
  password: String
  profile: UserProfileUpdateOneInput
}

input UserUpdateWithWhereUniqueWithoutSchemasInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutSchemasDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutSchemasInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutSchemasDataInput!
  create: UserCreateWithoutSchemasInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  profile: UserProfileWhereInput
  schemas_every: GqlSchemaWhereInput
  schemas_some: GqlSchemaWhereInput
  schemas_none: GqlSchemaWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    