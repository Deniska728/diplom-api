// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  commentContent: (where?: CommentContentWhereInput) => Promise<boolean>;
  gqlBaseType: (where?: GqlBaseTypeWhereInput) => Promise<boolean>;
  gqlDirective: (where?: GqlDirectiveWhereInput) => Promise<boolean>;
  gqlEnumValue: (where?: GqlEnumValueWhereInput) => Promise<boolean>;
  gqlField: (where?: GqlFieldWhereInput) => Promise<boolean>;
  gqlInputValue: (where?: GqlInputValueWhereInput) => Promise<boolean>;
  gqlIntrospectionSchema: (
    where?: GqlIntrospectionSchemaWhereInput
  ) => Promise<boolean>;
  gqlSchema: (where?: GqlSchemaWhereInput) => Promise<boolean>;
  gqlType: (where?: GqlTypeWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userProfile: (where?: UserProfileWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  commentContent: (
    where: CommentContentWhereUniqueInput
  ) => CommentContentNullablePromise;
  commentContents: (args?: {
    where?: CommentContentWhereInput;
    orderBy?: CommentContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CommentContent>;
  commentContentsConnection: (args?: {
    where?: CommentContentWhereInput;
    orderBy?: CommentContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentContentConnectionPromise;
  gqlBaseType: (
    where: GqlBaseTypeWhereUniqueInput
  ) => GqlBaseTypeNullablePromise;
  gqlBaseTypes: (args?: {
    where?: GqlBaseTypeWhereInput;
    orderBy?: GqlBaseTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GqlBaseType>;
  gqlBaseTypesConnection: (args?: {
    where?: GqlBaseTypeWhereInput;
    orderBy?: GqlBaseTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GqlBaseTypeConnectionPromise;
  gqlDirective: (
    where: GqlDirectiveWhereUniqueInput
  ) => GqlDirectiveNullablePromise;
  gqlDirectives: (args?: {
    where?: GqlDirectiveWhereInput;
    orderBy?: GqlDirectiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GqlDirective>;
  gqlDirectivesConnection: (args?: {
    where?: GqlDirectiveWhereInput;
    orderBy?: GqlDirectiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GqlDirectiveConnectionPromise;
  gqlEnumValue: (
    where: GqlEnumValueWhereUniqueInput
  ) => GqlEnumValueNullablePromise;
  gqlEnumValues: (args?: {
    where?: GqlEnumValueWhereInput;
    orderBy?: GqlEnumValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GqlEnumValue>;
  gqlEnumValuesConnection: (args?: {
    where?: GqlEnumValueWhereInput;
    orderBy?: GqlEnumValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GqlEnumValueConnectionPromise;
  gqlField: (where: GqlFieldWhereUniqueInput) => GqlFieldNullablePromise;
  gqlFields: (args?: {
    where?: GqlFieldWhereInput;
    orderBy?: GqlFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GqlField>;
  gqlFieldsConnection: (args?: {
    where?: GqlFieldWhereInput;
    orderBy?: GqlFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GqlFieldConnectionPromise;
  gqlInputValue: (
    where: GqlInputValueWhereUniqueInput
  ) => GqlInputValueNullablePromise;
  gqlInputValues: (args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GqlInputValue>;
  gqlInputValuesConnection: (args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GqlInputValueConnectionPromise;
  gqlIntrospectionSchema: (
    where: GqlIntrospectionSchemaWhereUniqueInput
  ) => GqlIntrospectionSchemaNullablePromise;
  gqlIntrospectionSchemas: (args?: {
    where?: GqlIntrospectionSchemaWhereInput;
    orderBy?: GqlIntrospectionSchemaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GqlIntrospectionSchema>;
  gqlIntrospectionSchemasConnection: (args?: {
    where?: GqlIntrospectionSchemaWhereInput;
    orderBy?: GqlIntrospectionSchemaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GqlIntrospectionSchemaConnectionPromise;
  gqlSchema: (where: GqlSchemaWhereUniqueInput) => GqlSchemaNullablePromise;
  gqlSchemas: (args?: {
    where?: GqlSchemaWhereInput;
    orderBy?: GqlSchemaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GqlSchema>;
  gqlSchemasConnection: (args?: {
    where?: GqlSchemaWhereInput;
    orderBy?: GqlSchemaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GqlSchemaConnectionPromise;
  gqlType: (where: GqlTypeWhereUniqueInput) => GqlTypeNullablePromise;
  gqlTypes: (args?: {
    where?: GqlTypeWhereInput;
    orderBy?: GqlTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GqlType>;
  gqlTypesConnection: (args?: {
    where?: GqlTypeWhereInput;
    orderBy?: GqlTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GqlTypeConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userProfile: (
    where: UserProfileWhereUniqueInput
  ) => UserProfileNullablePromise;
  userProfiles: (args?: {
    where?: UserProfileWhereInput;
    orderBy?: UserProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserProfile>;
  userProfilesConnection: (args?: {
    where?: UserProfileWhereInput;
    orderBy?: UserProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserProfileConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createCommentContent: (
    data: CommentContentCreateInput
  ) => CommentContentPromise;
  updateCommentContent: (args: {
    data: CommentContentUpdateInput;
    where: CommentContentWhereUniqueInput;
  }) => CommentContentPromise;
  updateManyCommentContents: (args: {
    data: CommentContentUpdateManyMutationInput;
    where?: CommentContentWhereInput;
  }) => BatchPayloadPromise;
  upsertCommentContent: (args: {
    where: CommentContentWhereUniqueInput;
    create: CommentContentCreateInput;
    update: CommentContentUpdateInput;
  }) => CommentContentPromise;
  deleteCommentContent: (
    where: CommentContentWhereUniqueInput
  ) => CommentContentPromise;
  deleteManyCommentContents: (
    where?: CommentContentWhereInput
  ) => BatchPayloadPromise;
  createGqlBaseType: (data: GqlBaseTypeCreateInput) => GqlBaseTypePromise;
  updateGqlBaseType: (args: {
    data: GqlBaseTypeUpdateInput;
    where: GqlBaseTypeWhereUniqueInput;
  }) => GqlBaseTypePromise;
  updateManyGqlBaseTypes: (args: {
    data: GqlBaseTypeUpdateManyMutationInput;
    where?: GqlBaseTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertGqlBaseType: (args: {
    where: GqlBaseTypeWhereUniqueInput;
    create: GqlBaseTypeCreateInput;
    update: GqlBaseTypeUpdateInput;
  }) => GqlBaseTypePromise;
  deleteGqlBaseType: (where: GqlBaseTypeWhereUniqueInput) => GqlBaseTypePromise;
  deleteManyGqlBaseTypes: (
    where?: GqlBaseTypeWhereInput
  ) => BatchPayloadPromise;
  createGqlDirective: (data: GqlDirectiveCreateInput) => GqlDirectivePromise;
  updateGqlDirective: (args: {
    data: GqlDirectiveUpdateInput;
    where: GqlDirectiveWhereUniqueInput;
  }) => GqlDirectivePromise;
  updateManyGqlDirectives: (args: {
    data: GqlDirectiveUpdateManyMutationInput;
    where?: GqlDirectiveWhereInput;
  }) => BatchPayloadPromise;
  upsertGqlDirective: (args: {
    where: GqlDirectiveWhereUniqueInput;
    create: GqlDirectiveCreateInput;
    update: GqlDirectiveUpdateInput;
  }) => GqlDirectivePromise;
  deleteGqlDirective: (
    where: GqlDirectiveWhereUniqueInput
  ) => GqlDirectivePromise;
  deleteManyGqlDirectives: (
    where?: GqlDirectiveWhereInput
  ) => BatchPayloadPromise;
  createGqlEnumValue: (data: GqlEnumValueCreateInput) => GqlEnumValuePromise;
  updateGqlEnumValue: (args: {
    data: GqlEnumValueUpdateInput;
    where: GqlEnumValueWhereUniqueInput;
  }) => GqlEnumValuePromise;
  updateManyGqlEnumValues: (args: {
    data: GqlEnumValueUpdateManyMutationInput;
    where?: GqlEnumValueWhereInput;
  }) => BatchPayloadPromise;
  upsertGqlEnumValue: (args: {
    where: GqlEnumValueWhereUniqueInput;
    create: GqlEnumValueCreateInput;
    update: GqlEnumValueUpdateInput;
  }) => GqlEnumValuePromise;
  deleteGqlEnumValue: (
    where: GqlEnumValueWhereUniqueInput
  ) => GqlEnumValuePromise;
  deleteManyGqlEnumValues: (
    where?: GqlEnumValueWhereInput
  ) => BatchPayloadPromise;
  createGqlField: (data: GqlFieldCreateInput) => GqlFieldPromise;
  updateGqlField: (args: {
    data: GqlFieldUpdateInput;
    where: GqlFieldWhereUniqueInput;
  }) => GqlFieldPromise;
  updateManyGqlFields: (args: {
    data: GqlFieldUpdateManyMutationInput;
    where?: GqlFieldWhereInput;
  }) => BatchPayloadPromise;
  upsertGqlField: (args: {
    where: GqlFieldWhereUniqueInput;
    create: GqlFieldCreateInput;
    update: GqlFieldUpdateInput;
  }) => GqlFieldPromise;
  deleteGqlField: (where: GqlFieldWhereUniqueInput) => GqlFieldPromise;
  deleteManyGqlFields: (where?: GqlFieldWhereInput) => BatchPayloadPromise;
  createGqlInputValue: (data: GqlInputValueCreateInput) => GqlInputValuePromise;
  updateGqlInputValue: (args: {
    data: GqlInputValueUpdateInput;
    where: GqlInputValueWhereUniqueInput;
  }) => GqlInputValuePromise;
  updateManyGqlInputValues: (args: {
    data: GqlInputValueUpdateManyMutationInput;
    where?: GqlInputValueWhereInput;
  }) => BatchPayloadPromise;
  upsertGqlInputValue: (args: {
    where: GqlInputValueWhereUniqueInput;
    create: GqlInputValueCreateInput;
    update: GqlInputValueUpdateInput;
  }) => GqlInputValuePromise;
  deleteGqlInputValue: (
    where: GqlInputValueWhereUniqueInput
  ) => GqlInputValuePromise;
  deleteManyGqlInputValues: (
    where?: GqlInputValueWhereInput
  ) => BatchPayloadPromise;
  createGqlIntrospectionSchema: (
    data: GqlIntrospectionSchemaCreateInput
  ) => GqlIntrospectionSchemaPromise;
  updateGqlIntrospectionSchema: (args: {
    data: GqlIntrospectionSchemaUpdateInput;
    where: GqlIntrospectionSchemaWhereUniqueInput;
  }) => GqlIntrospectionSchemaPromise;
  updateManyGqlIntrospectionSchemas: (args: {
    data: GqlIntrospectionSchemaUpdateManyMutationInput;
    where?: GqlIntrospectionSchemaWhereInput;
  }) => BatchPayloadPromise;
  upsertGqlIntrospectionSchema: (args: {
    where: GqlIntrospectionSchemaWhereUniqueInput;
    create: GqlIntrospectionSchemaCreateInput;
    update: GqlIntrospectionSchemaUpdateInput;
  }) => GqlIntrospectionSchemaPromise;
  deleteGqlIntrospectionSchema: (
    where: GqlIntrospectionSchemaWhereUniqueInput
  ) => GqlIntrospectionSchemaPromise;
  deleteManyGqlIntrospectionSchemas: (
    where?: GqlIntrospectionSchemaWhereInput
  ) => BatchPayloadPromise;
  createGqlSchema: (data: GqlSchemaCreateInput) => GqlSchemaPromise;
  updateGqlSchema: (args: {
    data: GqlSchemaUpdateInput;
    where: GqlSchemaWhereUniqueInput;
  }) => GqlSchemaPromise;
  updateManyGqlSchemas: (args: {
    data: GqlSchemaUpdateManyMutationInput;
    where?: GqlSchemaWhereInput;
  }) => BatchPayloadPromise;
  upsertGqlSchema: (args: {
    where: GqlSchemaWhereUniqueInput;
    create: GqlSchemaCreateInput;
    update: GqlSchemaUpdateInput;
  }) => GqlSchemaPromise;
  deleteGqlSchema: (where: GqlSchemaWhereUniqueInput) => GqlSchemaPromise;
  deleteManyGqlSchemas: (where?: GqlSchemaWhereInput) => BatchPayloadPromise;
  createGqlType: (data: GqlTypeCreateInput) => GqlTypePromise;
  updateGqlType: (args: {
    data: GqlTypeUpdateInput;
    where: GqlTypeWhereUniqueInput;
  }) => GqlTypePromise;
  updateManyGqlTypes: (args: {
    data: GqlTypeUpdateManyMutationInput;
    where?: GqlTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertGqlType: (args: {
    where: GqlTypeWhereUniqueInput;
    create: GqlTypeCreateInput;
    update: GqlTypeUpdateInput;
  }) => GqlTypePromise;
  deleteGqlType: (where: GqlTypeWhereUniqueInput) => GqlTypePromise;
  deleteManyGqlTypes: (where?: GqlTypeWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserProfile: (data: UserProfileCreateInput) => UserProfilePromise;
  updateUserProfile: (args: {
    data: UserProfileUpdateInput;
    where: UserProfileWhereUniqueInput;
  }) => UserProfilePromise;
  updateManyUserProfiles: (args: {
    data: UserProfileUpdateManyMutationInput;
    where?: UserProfileWhereInput;
  }) => BatchPayloadPromise;
  upsertUserProfile: (args: {
    where: UserProfileWhereUniqueInput;
    create: UserProfileCreateInput;
    update: UserProfileUpdateInput;
  }) => UserProfilePromise;
  deleteUserProfile: (where: UserProfileWhereUniqueInput) => UserProfilePromise;
  deleteManyUserProfiles: (
    where?: UserProfileWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  commentContent: (
    where?: CommentContentSubscriptionWhereInput
  ) => CommentContentSubscriptionPayloadSubscription;
  gqlBaseType: (
    where?: GqlBaseTypeSubscriptionWhereInput
  ) => GqlBaseTypeSubscriptionPayloadSubscription;
  gqlDirective: (
    where?: GqlDirectiveSubscriptionWhereInput
  ) => GqlDirectiveSubscriptionPayloadSubscription;
  gqlEnumValue: (
    where?: GqlEnumValueSubscriptionWhereInput
  ) => GqlEnumValueSubscriptionPayloadSubscription;
  gqlField: (
    where?: GqlFieldSubscriptionWhereInput
  ) => GqlFieldSubscriptionPayloadSubscription;
  gqlInputValue: (
    where?: GqlInputValueSubscriptionWhereInput
  ) => GqlInputValueSubscriptionPayloadSubscription;
  gqlIntrospectionSchema: (
    where?: GqlIntrospectionSchemaSubscriptionWhereInput
  ) => GqlIntrospectionSchemaSubscriptionPayloadSubscription;
  gqlSchema: (
    where?: GqlSchemaSubscriptionWhereInput
  ) => GqlSchemaSubscriptionPayloadSubscription;
  gqlType: (
    where?: GqlTypeSubscriptionWhereInput
  ) => GqlTypeSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userProfile: (
    where?: UserProfileSubscriptionWhereInput
  ) => UserProfileSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type GqlTypeKind =
  | "SCALAR"
  | "OBJECT"
  | "INTERFACE"
  | "UNION"
  | "ENUM"
  | "INPUT_OBJECT"
  | "LIST"
  | "NON_NULL";

export type GqlTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "kind_ASC"
  | "kind_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type GqlDirectiveOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type GqlDirectiveLocation =
  | "QUERY"
  | "MUTATION"
  | "SUBSCRIPTION"
  | "FIELD"
  | "FRAGMENT_DEFINITION"
  | "FRAGMENT_SPREAD"
  | "INLINE_FRAGMENT"
  | "SCHEMA"
  | "SCALAR"
  | "OBJECT"
  | "FIELD_DEFINITION"
  | "ARGUMENT_DEFINITION"
  | "INTERFACE"
  | "UNION"
  | "ENUM"
  | "ENUM_VALUE"
  | "INPUT_OBJECT"
  | "INPUT_FIELD_DEFINITION";

export type GqlInputValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "typeName_ASC"
  | "typeName_DESC"
  | "description_ASC"
  | "description_DESC"
  | "defaultValue_ASC"
  | "defaultValue_DESC";

export type GqlFieldOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "typeName_ASC"
  | "typeName_DESC"
  | "isDeprecated_ASC"
  | "isDeprecated_DESC"
  | "deprecationReason_ASC"
  | "deprecationReason_DESC";

export type GqlBaseTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "kind_ASC"
  | "kind_DESC"
  | "name_ASC"
  | "name_DESC";

export type GqlEnumValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "isDeprecated_ASC"
  | "isDeprecated_DESC"
  | "deprecationReason_ASC"
  | "deprecationReason_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type GqlSchemaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "apiKey_ASC"
  | "apiKey_DESC"
  | "endpointUrl_ASC"
  | "endpointUrl_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "sub_ASC"
  | "sub_DESC"
  | "email_ASC"
  | "email_DESC"
  | "username_ASC"
  | "username_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentContentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC";

export type GqlIntrospectionSchemaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type UserProfileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "fullName_ASC"
  | "fullName_DESC"
  | "picture_ASC"
  | "picture_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GqlTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  kind?: Maybe<GqlTypeKind>;
  kind_not?: Maybe<GqlTypeKind>;
  kind_in?: Maybe<GqlTypeKind[] | GqlTypeKind>;
  kind_not_in?: Maybe<GqlTypeKind[] | GqlTypeKind>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  schema?: Maybe<GqlIntrospectionSchemaWhereInput>;
  fields_every?: Maybe<GqlFieldWhereInput>;
  fields_some?: Maybe<GqlFieldWhereInput>;
  fields_none?: Maybe<GqlFieldWhereInput>;
  interfaces_every?: Maybe<GqlBaseTypeWhereInput>;
  interfaces_some?: Maybe<GqlBaseTypeWhereInput>;
  interfaces_none?: Maybe<GqlBaseTypeWhereInput>;
  possibleTypes_every?: Maybe<GqlBaseTypeWhereInput>;
  possibleTypes_some?: Maybe<GqlBaseTypeWhereInput>;
  possibleTypes_none?: Maybe<GqlBaseTypeWhereInput>;
  enumValues_every?: Maybe<GqlEnumValueWhereInput>;
  enumValues_some?: Maybe<GqlEnumValueWhereInput>;
  enumValues_none?: Maybe<GqlEnumValueWhereInput>;
  inputFields_every?: Maybe<GqlInputValueWhereInput>;
  inputFields_some?: Maybe<GqlInputValueWhereInput>;
  inputFields_none?: Maybe<GqlInputValueWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  AND?: Maybe<GqlTypeWhereInput[] | GqlTypeWhereInput>;
  OR?: Maybe<GqlTypeWhereInput[] | GqlTypeWhereInput>;
  NOT?: Maybe<GqlTypeWhereInput[] | GqlTypeWhereInput>;
}

export interface GqlIntrospectionSchemaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  types_every?: Maybe<GqlTypeWhereInput>;
  types_some?: Maybe<GqlTypeWhereInput>;
  types_none?: Maybe<GqlTypeWhereInput>;
  directives_every?: Maybe<GqlDirectiveWhereInput>;
  directives_some?: Maybe<GqlDirectiveWhereInput>;
  directives_none?: Maybe<GqlDirectiveWhereInput>;
  AND?: Maybe<
    GqlIntrospectionSchemaWhereInput[] | GqlIntrospectionSchemaWhereInput
  >;
  OR?: Maybe<
    GqlIntrospectionSchemaWhereInput[] | GqlIntrospectionSchemaWhereInput
  >;
  NOT?: Maybe<
    GqlIntrospectionSchemaWhereInput[] | GqlIntrospectionSchemaWhereInput
  >;
}

export interface GqlDirectiveWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  args_every?: Maybe<GqlInputValueWhereInput>;
  args_some?: Maybe<GqlInputValueWhereInput>;
  args_none?: Maybe<GqlInputValueWhereInput>;
  AND?: Maybe<GqlDirectiveWhereInput[] | GqlDirectiveWhereInput>;
  OR?: Maybe<GqlDirectiveWhereInput[] | GqlDirectiveWhereInput>;
  NOT?: Maybe<GqlDirectiveWhereInput[] | GqlDirectiveWhereInput>;
}

export interface GqlInputValueWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  typeName?: Maybe<String>;
  typeName_not?: Maybe<String>;
  typeName_in?: Maybe<String[] | String>;
  typeName_not_in?: Maybe<String[] | String>;
  typeName_lt?: Maybe<String>;
  typeName_lte?: Maybe<String>;
  typeName_gt?: Maybe<String>;
  typeName_gte?: Maybe<String>;
  typeName_contains?: Maybe<String>;
  typeName_not_contains?: Maybe<String>;
  typeName_starts_with?: Maybe<String>;
  typeName_not_starts_with?: Maybe<String>;
  typeName_ends_with?: Maybe<String>;
  typeName_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  defaultValue?: Maybe<String>;
  defaultValue_not?: Maybe<String>;
  defaultValue_in?: Maybe<String[] | String>;
  defaultValue_not_in?: Maybe<String[] | String>;
  defaultValue_lt?: Maybe<String>;
  defaultValue_lte?: Maybe<String>;
  defaultValue_gt?: Maybe<String>;
  defaultValue_gte?: Maybe<String>;
  defaultValue_contains?: Maybe<String>;
  defaultValue_not_contains?: Maybe<String>;
  defaultValue_starts_with?: Maybe<String>;
  defaultValue_not_starts_with?: Maybe<String>;
  defaultValue_ends_with?: Maybe<String>;
  defaultValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<GqlInputValueWhereInput[] | GqlInputValueWhereInput>;
  OR?: Maybe<GqlInputValueWhereInput[] | GqlInputValueWhereInput>;
  NOT?: Maybe<GqlInputValueWhereInput[] | GqlInputValueWhereInput>;
}

export interface GqlFieldWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  typeName?: Maybe<String>;
  typeName_not?: Maybe<String>;
  typeName_in?: Maybe<String[] | String>;
  typeName_not_in?: Maybe<String[] | String>;
  typeName_lt?: Maybe<String>;
  typeName_lte?: Maybe<String>;
  typeName_gt?: Maybe<String>;
  typeName_gte?: Maybe<String>;
  typeName_contains?: Maybe<String>;
  typeName_not_contains?: Maybe<String>;
  typeName_starts_with?: Maybe<String>;
  typeName_not_starts_with?: Maybe<String>;
  typeName_ends_with?: Maybe<String>;
  typeName_not_ends_with?: Maybe<String>;
  args_every?: Maybe<GqlInputValueWhereInput>;
  args_some?: Maybe<GqlInputValueWhereInput>;
  args_none?: Maybe<GqlInputValueWhereInput>;
  isDeprecated?: Maybe<Boolean>;
  isDeprecated_not?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
  deprecationReason_not?: Maybe<String>;
  deprecationReason_in?: Maybe<String[] | String>;
  deprecationReason_not_in?: Maybe<String[] | String>;
  deprecationReason_lt?: Maybe<String>;
  deprecationReason_lte?: Maybe<String>;
  deprecationReason_gt?: Maybe<String>;
  deprecationReason_gte?: Maybe<String>;
  deprecationReason_contains?: Maybe<String>;
  deprecationReason_not_contains?: Maybe<String>;
  deprecationReason_starts_with?: Maybe<String>;
  deprecationReason_not_starts_with?: Maybe<String>;
  deprecationReason_ends_with?: Maybe<String>;
  deprecationReason_not_ends_with?: Maybe<String>;
  AND?: Maybe<GqlFieldWhereInput[] | GqlFieldWhereInput>;
  OR?: Maybe<GqlFieldWhereInput[] | GqlFieldWhereInput>;
  NOT?: Maybe<GqlFieldWhereInput[] | GqlFieldWhereInput>;
}

export interface GqlBaseTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  kind?: Maybe<GqlTypeKind>;
  kind_not?: Maybe<GqlTypeKind>;
  kind_in?: Maybe<GqlTypeKind[] | GqlTypeKind>;
  kind_not_in?: Maybe<GqlTypeKind[] | GqlTypeKind>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<GqlBaseTypeWhereInput[] | GqlBaseTypeWhereInput>;
  OR?: Maybe<GqlBaseTypeWhereInput[] | GqlBaseTypeWhereInput>;
  NOT?: Maybe<GqlBaseTypeWhereInput[] | GqlBaseTypeWhereInput>;
}

export interface GqlEnumValueWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  isDeprecated?: Maybe<Boolean>;
  isDeprecated_not?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
  deprecationReason_not?: Maybe<String>;
  deprecationReason_in?: Maybe<String[] | String>;
  deprecationReason_not_in?: Maybe<String[] | String>;
  deprecationReason_lt?: Maybe<String>;
  deprecationReason_lte?: Maybe<String>;
  deprecationReason_gt?: Maybe<String>;
  deprecationReason_gte?: Maybe<String>;
  deprecationReason_contains?: Maybe<String>;
  deprecationReason_not_contains?: Maybe<String>;
  deprecationReason_starts_with?: Maybe<String>;
  deprecationReason_not_starts_with?: Maybe<String>;
  deprecationReason_ends_with?: Maybe<String>;
  deprecationReason_not_ends_with?: Maybe<String>;
  AND?: Maybe<GqlEnumValueWhereInput[] | GqlEnumValueWhereInput>;
  OR?: Maybe<GqlEnumValueWhereInput[] | GqlEnumValueWhereInput>;
  NOT?: Maybe<GqlEnumValueWhereInput[] | GqlEnumValueWhereInput>;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<CommentContentWhereInput>;
  gqlType?: Maybe<GqlTypeWhereInput>;
  createdBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface CommentContentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  AND?: Maybe<CommentContentWhereInput[] | CommentContentWhereInput>;
  OR?: Maybe<CommentContentWhereInput[] | CommentContentWhereInput>;
  NOT?: Maybe<CommentContentWhereInput[] | CommentContentWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  sub?: Maybe<String>;
  sub_not?: Maybe<String>;
  sub_in?: Maybe<String[] | String>;
  sub_not_in?: Maybe<String[] | String>;
  sub_lt?: Maybe<String>;
  sub_lte?: Maybe<String>;
  sub_gt?: Maybe<String>;
  sub_gte?: Maybe<String>;
  sub_contains?: Maybe<String>;
  sub_not_contains?: Maybe<String>;
  sub_starts_with?: Maybe<String>;
  sub_not_starts_with?: Maybe<String>;
  sub_ends_with?: Maybe<String>;
  sub_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  profile?: Maybe<UserProfileWhereInput>;
  schemas_every?: Maybe<GqlSchemaWhereInput>;
  schemas_some?: Maybe<GqlSchemaWhereInput>;
  schemas_none?: Maybe<GqlSchemaWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface UserProfileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  fullName?: Maybe<String>;
  fullName_not?: Maybe<String>;
  fullName_in?: Maybe<String[] | String>;
  fullName_not_in?: Maybe<String[] | String>;
  fullName_lt?: Maybe<String>;
  fullName_lte?: Maybe<String>;
  fullName_gt?: Maybe<String>;
  fullName_gte?: Maybe<String>;
  fullName_contains?: Maybe<String>;
  fullName_not_contains?: Maybe<String>;
  fullName_starts_with?: Maybe<String>;
  fullName_not_starts_with?: Maybe<String>;
  fullName_ends_with?: Maybe<String>;
  fullName_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserProfileWhereInput[] | UserProfileWhereInput>;
  OR?: Maybe<UserProfileWhereInput[] | UserProfileWhereInput>;
  NOT?: Maybe<UserProfileWhereInput[] | UserProfileWhereInput>;
}

export interface GqlSchemaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  owner?: Maybe<UserWhereInput>;
  members_every?: Maybe<UserWhereInput>;
  members_some?: Maybe<UserWhereInput>;
  members_none?: Maybe<UserWhereInput>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  introspectionSchema?: Maybe<GqlIntrospectionSchemaWhereInput>;
  endpointUrl?: Maybe<String>;
  endpointUrl_not?: Maybe<String>;
  endpointUrl_in?: Maybe<String[] | String>;
  endpointUrl_not_in?: Maybe<String[] | String>;
  endpointUrl_lt?: Maybe<String>;
  endpointUrl_lte?: Maybe<String>;
  endpointUrl_gt?: Maybe<String>;
  endpointUrl_gte?: Maybe<String>;
  endpointUrl_contains?: Maybe<String>;
  endpointUrl_not_contains?: Maybe<String>;
  endpointUrl_starts_with?: Maybe<String>;
  endpointUrl_not_starts_with?: Maybe<String>;
  endpointUrl_ends_with?: Maybe<String>;
  endpointUrl_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GqlSchemaWhereInput[] | GqlSchemaWhereInput>;
  OR?: Maybe<GqlSchemaWhereInput[] | GqlSchemaWhereInput>;
  NOT?: Maybe<GqlSchemaWhereInput[] | GqlSchemaWhereInput>;
}

export type CommentContentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GqlBaseTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GqlDirectiveWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GqlEnumValueWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GqlFieldWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GqlInputValueWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GqlIntrospectionSchemaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GqlSchemaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GqlTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  sub?: Maybe<String>;
}>;

export type UserProfileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  content: CommentContentCreateOneInput;
  gqlType?: Maybe<GqlTypeCreateOneWithoutCommentsInput>;
  createdBy: UserCreateOneInput;
}

export interface CommentContentCreateOneInput {
  create?: Maybe<CommentContentCreateInput>;
  connect?: Maybe<CommentContentWhereUniqueInput>;
}

export interface CommentContentCreateInput {
  id?: Maybe<ID_Input>;
  message: String;
}

export interface GqlTypeCreateOneWithoutCommentsInput {
  create?: Maybe<GqlTypeCreateWithoutCommentsInput>;
  connect?: Maybe<GqlTypeWhereUniqueInput>;
}

export interface GqlTypeCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  kind: GqlTypeKind;
  name?: Maybe<String>;
  description?: Maybe<String>;
  schema: GqlIntrospectionSchemaCreateOneWithoutTypesInput;
  fields?: Maybe<GqlFieldCreateManyInput>;
  interfaces?: Maybe<GqlBaseTypeCreateManyInput>;
  possibleTypes?: Maybe<GqlBaseTypeCreateManyInput>;
  enumValues?: Maybe<GqlEnumValueCreateManyInput>;
  inputFields?: Maybe<GqlInputValueCreateManyInput>;
}

export interface GqlIntrospectionSchemaCreateOneWithoutTypesInput {
  create?: Maybe<GqlIntrospectionSchemaCreateWithoutTypesInput>;
  connect?: Maybe<GqlIntrospectionSchemaWhereUniqueInput>;
}

export interface GqlIntrospectionSchemaCreateWithoutTypesInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  directives?: Maybe<GqlDirectiveCreateManyInput>;
}

export interface GqlDirectiveCreateManyInput {
  create?: Maybe<GqlDirectiveCreateInput[] | GqlDirectiveCreateInput>;
  connect?: Maybe<
    GqlDirectiveWhereUniqueInput[] | GqlDirectiveWhereUniqueInput
  >;
}

export interface GqlDirectiveCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  locations?: Maybe<GqlDirectiveCreatelocationsInput>;
  args?: Maybe<GqlInputValueCreateManyInput>;
}

export interface GqlDirectiveCreatelocationsInput {
  set?: Maybe<GqlDirectiveLocation[] | GqlDirectiveLocation>;
}

export interface GqlInputValueCreateManyInput {
  create?: Maybe<GqlInputValueCreateInput[] | GqlInputValueCreateInput>;
  connect?: Maybe<
    GqlInputValueWhereUniqueInput[] | GqlInputValueWhereUniqueInput
  >;
}

export interface GqlInputValueCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  kinds?: Maybe<GqlInputValueCreatekindsInput>;
  typeName?: Maybe<String>;
  description?: Maybe<String>;
  defaultValue?: Maybe<String>;
}

export interface GqlInputValueCreatekindsInput {
  set?: Maybe<GqlTypeKind[] | GqlTypeKind>;
}

export interface GqlFieldCreateManyInput {
  create?: Maybe<GqlFieldCreateInput[] | GqlFieldCreateInput>;
  connect?: Maybe<GqlFieldWhereUniqueInput[] | GqlFieldWhereUniqueInput>;
}

export interface GqlFieldCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  typeName?: Maybe<String>;
  kinds?: Maybe<GqlFieldCreatekindsInput>;
  args?: Maybe<GqlInputValueCreateManyInput>;
  isDeprecated: Boolean;
  deprecationReason?: Maybe<String>;
}

export interface GqlFieldCreatekindsInput {
  set?: Maybe<GqlTypeKind[] | GqlTypeKind>;
}

export interface GqlBaseTypeCreateManyInput {
  create?: Maybe<GqlBaseTypeCreateInput[] | GqlBaseTypeCreateInput>;
  connect?: Maybe<GqlBaseTypeWhereUniqueInput[] | GqlBaseTypeWhereUniqueInput>;
}

export interface GqlBaseTypeCreateInput {
  id?: Maybe<ID_Input>;
  kind: GqlTypeKind;
  name: String;
}

export interface GqlEnumValueCreateManyInput {
  create?: Maybe<GqlEnumValueCreateInput[] | GqlEnumValueCreateInput>;
  connect?: Maybe<
    GqlEnumValueWhereUniqueInput[] | GqlEnumValueWhereUniqueInput
  >;
}

export interface GqlEnumValueCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  isDeprecated: Boolean;
  deprecationReason?: Maybe<String>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  sub: String;
  email: String;
  username: String;
  profile?: Maybe<UserProfileCreateOneInput>;
  schemas?: Maybe<GqlSchemaCreateManyWithoutMembersInput>;
}

export interface UserProfileCreateOneInput {
  create?: Maybe<UserProfileCreateInput>;
  connect?: Maybe<UserProfileWhereUniqueInput>;
}

export interface UserProfileCreateInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  fullName?: Maybe<String>;
  picture?: Maybe<String>;
}

export interface GqlSchemaCreateManyWithoutMembersInput {
  create?: Maybe<
    GqlSchemaCreateWithoutMembersInput[] | GqlSchemaCreateWithoutMembersInput
  >;
  connect?: Maybe<GqlSchemaWhereUniqueInput[] | GqlSchemaWhereUniqueInput>;
}

export interface GqlSchemaCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  name: String;
  owner?: Maybe<UserCreateOneInput>;
  apiKey: String;
  introspectionSchema?: Maybe<GqlIntrospectionSchemaCreateOneInput>;
  endpointUrl?: Maybe<String>;
}

export interface GqlIntrospectionSchemaCreateOneInput {
  create?: Maybe<GqlIntrospectionSchemaCreateInput>;
  connect?: Maybe<GqlIntrospectionSchemaWhereUniqueInput>;
}

export interface GqlIntrospectionSchemaCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  types?: Maybe<GqlTypeCreateManyWithoutSchemaInput>;
  directives?: Maybe<GqlDirectiveCreateManyInput>;
}

export interface GqlTypeCreateManyWithoutSchemaInput {
  create?: Maybe<
    GqlTypeCreateWithoutSchemaInput[] | GqlTypeCreateWithoutSchemaInput
  >;
  connect?: Maybe<GqlTypeWhereUniqueInput[] | GqlTypeWhereUniqueInput>;
}

export interface GqlTypeCreateWithoutSchemaInput {
  id?: Maybe<ID_Input>;
  kind: GqlTypeKind;
  name?: Maybe<String>;
  description?: Maybe<String>;
  fields?: Maybe<GqlFieldCreateManyInput>;
  interfaces?: Maybe<GqlBaseTypeCreateManyInput>;
  possibleTypes?: Maybe<GqlBaseTypeCreateManyInput>;
  enumValues?: Maybe<GqlEnumValueCreateManyInput>;
  inputFields?: Maybe<GqlInputValueCreateManyInput>;
  comments?: Maybe<CommentCreateManyWithoutGqlTypeInput>;
}

export interface CommentCreateManyWithoutGqlTypeInput {
  create?: Maybe<
    CommentCreateWithoutGqlTypeInput[] | CommentCreateWithoutGqlTypeInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutGqlTypeInput {
  id?: Maybe<ID_Input>;
  content: CommentContentCreateOneInput;
  createdBy: UserCreateOneInput;
}

export interface CommentUpdateInput {
  content?: Maybe<CommentContentUpdateOneRequiredInput>;
  gqlType?: Maybe<GqlTypeUpdateOneWithoutCommentsInput>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CommentContentUpdateOneRequiredInput {
  create?: Maybe<CommentContentCreateInput>;
  update?: Maybe<CommentContentUpdateDataInput>;
  upsert?: Maybe<CommentContentUpsertNestedInput>;
  connect?: Maybe<CommentContentWhereUniqueInput>;
}

export interface CommentContentUpdateDataInput {
  message?: Maybe<String>;
}

export interface CommentContentUpsertNestedInput {
  update: CommentContentUpdateDataInput;
  create: CommentContentCreateInput;
}

export interface GqlTypeUpdateOneWithoutCommentsInput {
  create?: Maybe<GqlTypeCreateWithoutCommentsInput>;
  update?: Maybe<GqlTypeUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<GqlTypeUpsertWithoutCommentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<GqlTypeWhereUniqueInput>;
}

export interface GqlTypeUpdateWithoutCommentsDataInput {
  kind?: Maybe<GqlTypeKind>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  schema?: Maybe<GqlIntrospectionSchemaUpdateOneRequiredWithoutTypesInput>;
  fields?: Maybe<GqlFieldUpdateManyInput>;
  interfaces?: Maybe<GqlBaseTypeUpdateManyInput>;
  possibleTypes?: Maybe<GqlBaseTypeUpdateManyInput>;
  enumValues?: Maybe<GqlEnumValueUpdateManyInput>;
  inputFields?: Maybe<GqlInputValueUpdateManyInput>;
}

export interface GqlIntrospectionSchemaUpdateOneRequiredWithoutTypesInput {
  create?: Maybe<GqlIntrospectionSchemaCreateWithoutTypesInput>;
  update?: Maybe<GqlIntrospectionSchemaUpdateWithoutTypesDataInput>;
  upsert?: Maybe<GqlIntrospectionSchemaUpsertWithoutTypesInput>;
  connect?: Maybe<GqlIntrospectionSchemaWhereUniqueInput>;
}

export interface GqlIntrospectionSchemaUpdateWithoutTypesDataInput {
  name?: Maybe<String>;
  directives?: Maybe<GqlDirectiveUpdateManyInput>;
}

export interface GqlDirectiveUpdateManyInput {
  create?: Maybe<GqlDirectiveCreateInput[] | GqlDirectiveCreateInput>;
  update?: Maybe<
    | GqlDirectiveUpdateWithWhereUniqueNestedInput[]
    | GqlDirectiveUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GqlDirectiveUpsertWithWhereUniqueNestedInput[]
    | GqlDirectiveUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<GqlDirectiveWhereUniqueInput[] | GqlDirectiveWhereUniqueInput>;
  connect?: Maybe<
    GqlDirectiveWhereUniqueInput[] | GqlDirectiveWhereUniqueInput
  >;
  set?: Maybe<GqlDirectiveWhereUniqueInput[] | GqlDirectiveWhereUniqueInput>;
  disconnect?: Maybe<
    GqlDirectiveWhereUniqueInput[] | GqlDirectiveWhereUniqueInput
  >;
  deleteMany?: Maybe<
    GqlDirectiveScalarWhereInput[] | GqlDirectiveScalarWhereInput
  >;
  updateMany?: Maybe<
    | GqlDirectiveUpdateManyWithWhereNestedInput[]
    | GqlDirectiveUpdateManyWithWhereNestedInput
  >;
}

export interface GqlDirectiveUpdateWithWhereUniqueNestedInput {
  where: GqlDirectiveWhereUniqueInput;
  data: GqlDirectiveUpdateDataInput;
}

export interface GqlDirectiveUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  locations?: Maybe<GqlDirectiveUpdatelocationsInput>;
  args?: Maybe<GqlInputValueUpdateManyInput>;
}

export interface GqlDirectiveUpdatelocationsInput {
  set?: Maybe<GqlDirectiveLocation[] | GqlDirectiveLocation>;
}

export interface GqlInputValueUpdateManyInput {
  create?: Maybe<GqlInputValueCreateInput[] | GqlInputValueCreateInput>;
  update?: Maybe<
    | GqlInputValueUpdateWithWhereUniqueNestedInput[]
    | GqlInputValueUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GqlInputValueUpsertWithWhereUniqueNestedInput[]
    | GqlInputValueUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    GqlInputValueWhereUniqueInput[] | GqlInputValueWhereUniqueInput
  >;
  connect?: Maybe<
    GqlInputValueWhereUniqueInput[] | GqlInputValueWhereUniqueInput
  >;
  set?: Maybe<GqlInputValueWhereUniqueInput[] | GqlInputValueWhereUniqueInput>;
  disconnect?: Maybe<
    GqlInputValueWhereUniqueInput[] | GqlInputValueWhereUniqueInput
  >;
  deleteMany?: Maybe<
    GqlInputValueScalarWhereInput[] | GqlInputValueScalarWhereInput
  >;
  updateMany?: Maybe<
    | GqlInputValueUpdateManyWithWhereNestedInput[]
    | GqlInputValueUpdateManyWithWhereNestedInput
  >;
}

export interface GqlInputValueUpdateWithWhereUniqueNestedInput {
  where: GqlInputValueWhereUniqueInput;
  data: GqlInputValueUpdateDataInput;
}

export interface GqlInputValueUpdateDataInput {
  name?: Maybe<String>;
  kinds?: Maybe<GqlInputValueUpdatekindsInput>;
  typeName?: Maybe<String>;
  description?: Maybe<String>;
  defaultValue?: Maybe<String>;
}

export interface GqlInputValueUpdatekindsInput {
  set?: Maybe<GqlTypeKind[] | GqlTypeKind>;
}

export interface GqlInputValueUpsertWithWhereUniqueNestedInput {
  where: GqlInputValueWhereUniqueInput;
  update: GqlInputValueUpdateDataInput;
  create: GqlInputValueCreateInput;
}

export interface GqlInputValueScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  typeName?: Maybe<String>;
  typeName_not?: Maybe<String>;
  typeName_in?: Maybe<String[] | String>;
  typeName_not_in?: Maybe<String[] | String>;
  typeName_lt?: Maybe<String>;
  typeName_lte?: Maybe<String>;
  typeName_gt?: Maybe<String>;
  typeName_gte?: Maybe<String>;
  typeName_contains?: Maybe<String>;
  typeName_not_contains?: Maybe<String>;
  typeName_starts_with?: Maybe<String>;
  typeName_not_starts_with?: Maybe<String>;
  typeName_ends_with?: Maybe<String>;
  typeName_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  defaultValue?: Maybe<String>;
  defaultValue_not?: Maybe<String>;
  defaultValue_in?: Maybe<String[] | String>;
  defaultValue_not_in?: Maybe<String[] | String>;
  defaultValue_lt?: Maybe<String>;
  defaultValue_lte?: Maybe<String>;
  defaultValue_gt?: Maybe<String>;
  defaultValue_gte?: Maybe<String>;
  defaultValue_contains?: Maybe<String>;
  defaultValue_not_contains?: Maybe<String>;
  defaultValue_starts_with?: Maybe<String>;
  defaultValue_not_starts_with?: Maybe<String>;
  defaultValue_ends_with?: Maybe<String>;
  defaultValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<GqlInputValueScalarWhereInput[] | GqlInputValueScalarWhereInput>;
  OR?: Maybe<GqlInputValueScalarWhereInput[] | GqlInputValueScalarWhereInput>;
  NOT?: Maybe<GqlInputValueScalarWhereInput[] | GqlInputValueScalarWhereInput>;
}

export interface GqlInputValueUpdateManyWithWhereNestedInput {
  where: GqlInputValueScalarWhereInput;
  data: GqlInputValueUpdateManyDataInput;
}

export interface GqlInputValueUpdateManyDataInput {
  name?: Maybe<String>;
  kinds?: Maybe<GqlInputValueUpdatekindsInput>;
  typeName?: Maybe<String>;
  description?: Maybe<String>;
  defaultValue?: Maybe<String>;
}

export interface GqlDirectiveUpsertWithWhereUniqueNestedInput {
  where: GqlDirectiveWhereUniqueInput;
  update: GqlDirectiveUpdateDataInput;
  create: GqlDirectiveCreateInput;
}

export interface GqlDirectiveScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<GqlDirectiveScalarWhereInput[] | GqlDirectiveScalarWhereInput>;
  OR?: Maybe<GqlDirectiveScalarWhereInput[] | GqlDirectiveScalarWhereInput>;
  NOT?: Maybe<GqlDirectiveScalarWhereInput[] | GqlDirectiveScalarWhereInput>;
}

export interface GqlDirectiveUpdateManyWithWhereNestedInput {
  where: GqlDirectiveScalarWhereInput;
  data: GqlDirectiveUpdateManyDataInput;
}

export interface GqlDirectiveUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  locations?: Maybe<GqlDirectiveUpdatelocationsInput>;
}

export interface GqlIntrospectionSchemaUpsertWithoutTypesInput {
  update: GqlIntrospectionSchemaUpdateWithoutTypesDataInput;
  create: GqlIntrospectionSchemaCreateWithoutTypesInput;
}

export interface GqlFieldUpdateManyInput {
  create?: Maybe<GqlFieldCreateInput[] | GqlFieldCreateInput>;
  update?: Maybe<
    | GqlFieldUpdateWithWhereUniqueNestedInput[]
    | GqlFieldUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GqlFieldUpsertWithWhereUniqueNestedInput[]
    | GqlFieldUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<GqlFieldWhereUniqueInput[] | GqlFieldWhereUniqueInput>;
  connect?: Maybe<GqlFieldWhereUniqueInput[] | GqlFieldWhereUniqueInput>;
  set?: Maybe<GqlFieldWhereUniqueInput[] | GqlFieldWhereUniqueInput>;
  disconnect?: Maybe<GqlFieldWhereUniqueInput[] | GqlFieldWhereUniqueInput>;
  deleteMany?: Maybe<GqlFieldScalarWhereInput[] | GqlFieldScalarWhereInput>;
  updateMany?: Maybe<
    | GqlFieldUpdateManyWithWhereNestedInput[]
    | GqlFieldUpdateManyWithWhereNestedInput
  >;
}

export interface GqlFieldUpdateWithWhereUniqueNestedInput {
  where: GqlFieldWhereUniqueInput;
  data: GqlFieldUpdateDataInput;
}

export interface GqlFieldUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  typeName?: Maybe<String>;
  kinds?: Maybe<GqlFieldUpdatekindsInput>;
  args?: Maybe<GqlInputValueUpdateManyInput>;
  isDeprecated?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
}

export interface GqlFieldUpdatekindsInput {
  set?: Maybe<GqlTypeKind[] | GqlTypeKind>;
}

export interface GqlFieldUpsertWithWhereUniqueNestedInput {
  where: GqlFieldWhereUniqueInput;
  update: GqlFieldUpdateDataInput;
  create: GqlFieldCreateInput;
}

export interface GqlFieldScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  typeName?: Maybe<String>;
  typeName_not?: Maybe<String>;
  typeName_in?: Maybe<String[] | String>;
  typeName_not_in?: Maybe<String[] | String>;
  typeName_lt?: Maybe<String>;
  typeName_lte?: Maybe<String>;
  typeName_gt?: Maybe<String>;
  typeName_gte?: Maybe<String>;
  typeName_contains?: Maybe<String>;
  typeName_not_contains?: Maybe<String>;
  typeName_starts_with?: Maybe<String>;
  typeName_not_starts_with?: Maybe<String>;
  typeName_ends_with?: Maybe<String>;
  typeName_not_ends_with?: Maybe<String>;
  isDeprecated?: Maybe<Boolean>;
  isDeprecated_not?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
  deprecationReason_not?: Maybe<String>;
  deprecationReason_in?: Maybe<String[] | String>;
  deprecationReason_not_in?: Maybe<String[] | String>;
  deprecationReason_lt?: Maybe<String>;
  deprecationReason_lte?: Maybe<String>;
  deprecationReason_gt?: Maybe<String>;
  deprecationReason_gte?: Maybe<String>;
  deprecationReason_contains?: Maybe<String>;
  deprecationReason_not_contains?: Maybe<String>;
  deprecationReason_starts_with?: Maybe<String>;
  deprecationReason_not_starts_with?: Maybe<String>;
  deprecationReason_ends_with?: Maybe<String>;
  deprecationReason_not_ends_with?: Maybe<String>;
  AND?: Maybe<GqlFieldScalarWhereInput[] | GqlFieldScalarWhereInput>;
  OR?: Maybe<GqlFieldScalarWhereInput[] | GqlFieldScalarWhereInput>;
  NOT?: Maybe<GqlFieldScalarWhereInput[] | GqlFieldScalarWhereInput>;
}

export interface GqlFieldUpdateManyWithWhereNestedInput {
  where: GqlFieldScalarWhereInput;
  data: GqlFieldUpdateManyDataInput;
}

export interface GqlFieldUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  typeName?: Maybe<String>;
  kinds?: Maybe<GqlFieldUpdatekindsInput>;
  isDeprecated?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
}

export interface GqlBaseTypeUpdateManyInput {
  create?: Maybe<GqlBaseTypeCreateInput[] | GqlBaseTypeCreateInput>;
  update?: Maybe<
    | GqlBaseTypeUpdateWithWhereUniqueNestedInput[]
    | GqlBaseTypeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GqlBaseTypeUpsertWithWhereUniqueNestedInput[]
    | GqlBaseTypeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<GqlBaseTypeWhereUniqueInput[] | GqlBaseTypeWhereUniqueInput>;
  connect?: Maybe<GqlBaseTypeWhereUniqueInput[] | GqlBaseTypeWhereUniqueInput>;
  set?: Maybe<GqlBaseTypeWhereUniqueInput[] | GqlBaseTypeWhereUniqueInput>;
  disconnect?: Maybe<
    GqlBaseTypeWhereUniqueInput[] | GqlBaseTypeWhereUniqueInput
  >;
  deleteMany?: Maybe<
    GqlBaseTypeScalarWhereInput[] | GqlBaseTypeScalarWhereInput
  >;
  updateMany?: Maybe<
    | GqlBaseTypeUpdateManyWithWhereNestedInput[]
    | GqlBaseTypeUpdateManyWithWhereNestedInput
  >;
}

export interface GqlBaseTypeUpdateWithWhereUniqueNestedInput {
  where: GqlBaseTypeWhereUniqueInput;
  data: GqlBaseTypeUpdateDataInput;
}

export interface GqlBaseTypeUpdateDataInput {
  kind?: Maybe<GqlTypeKind>;
  name?: Maybe<String>;
}

export interface GqlBaseTypeUpsertWithWhereUniqueNestedInput {
  where: GqlBaseTypeWhereUniqueInput;
  update: GqlBaseTypeUpdateDataInput;
  create: GqlBaseTypeCreateInput;
}

export interface GqlBaseTypeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  kind?: Maybe<GqlTypeKind>;
  kind_not?: Maybe<GqlTypeKind>;
  kind_in?: Maybe<GqlTypeKind[] | GqlTypeKind>;
  kind_not_in?: Maybe<GqlTypeKind[] | GqlTypeKind>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<GqlBaseTypeScalarWhereInput[] | GqlBaseTypeScalarWhereInput>;
  OR?: Maybe<GqlBaseTypeScalarWhereInput[] | GqlBaseTypeScalarWhereInput>;
  NOT?: Maybe<GqlBaseTypeScalarWhereInput[] | GqlBaseTypeScalarWhereInput>;
}

export interface GqlBaseTypeUpdateManyWithWhereNestedInput {
  where: GqlBaseTypeScalarWhereInput;
  data: GqlBaseTypeUpdateManyDataInput;
}

export interface GqlBaseTypeUpdateManyDataInput {
  kind?: Maybe<GqlTypeKind>;
  name?: Maybe<String>;
}

export interface GqlEnumValueUpdateManyInput {
  create?: Maybe<GqlEnumValueCreateInput[] | GqlEnumValueCreateInput>;
  update?: Maybe<
    | GqlEnumValueUpdateWithWhereUniqueNestedInput[]
    | GqlEnumValueUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GqlEnumValueUpsertWithWhereUniqueNestedInput[]
    | GqlEnumValueUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<GqlEnumValueWhereUniqueInput[] | GqlEnumValueWhereUniqueInput>;
  connect?: Maybe<
    GqlEnumValueWhereUniqueInput[] | GqlEnumValueWhereUniqueInput
  >;
  set?: Maybe<GqlEnumValueWhereUniqueInput[] | GqlEnumValueWhereUniqueInput>;
  disconnect?: Maybe<
    GqlEnumValueWhereUniqueInput[] | GqlEnumValueWhereUniqueInput
  >;
  deleteMany?: Maybe<
    GqlEnumValueScalarWhereInput[] | GqlEnumValueScalarWhereInput
  >;
  updateMany?: Maybe<
    | GqlEnumValueUpdateManyWithWhereNestedInput[]
    | GqlEnumValueUpdateManyWithWhereNestedInput
  >;
}

export interface GqlEnumValueUpdateWithWhereUniqueNestedInput {
  where: GqlEnumValueWhereUniqueInput;
  data: GqlEnumValueUpdateDataInput;
}

export interface GqlEnumValueUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  isDeprecated?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
}

export interface GqlEnumValueUpsertWithWhereUniqueNestedInput {
  where: GqlEnumValueWhereUniqueInput;
  update: GqlEnumValueUpdateDataInput;
  create: GqlEnumValueCreateInput;
}

export interface GqlEnumValueScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  isDeprecated?: Maybe<Boolean>;
  isDeprecated_not?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
  deprecationReason_not?: Maybe<String>;
  deprecationReason_in?: Maybe<String[] | String>;
  deprecationReason_not_in?: Maybe<String[] | String>;
  deprecationReason_lt?: Maybe<String>;
  deprecationReason_lte?: Maybe<String>;
  deprecationReason_gt?: Maybe<String>;
  deprecationReason_gte?: Maybe<String>;
  deprecationReason_contains?: Maybe<String>;
  deprecationReason_not_contains?: Maybe<String>;
  deprecationReason_starts_with?: Maybe<String>;
  deprecationReason_not_starts_with?: Maybe<String>;
  deprecationReason_ends_with?: Maybe<String>;
  deprecationReason_not_ends_with?: Maybe<String>;
  AND?: Maybe<GqlEnumValueScalarWhereInput[] | GqlEnumValueScalarWhereInput>;
  OR?: Maybe<GqlEnumValueScalarWhereInput[] | GqlEnumValueScalarWhereInput>;
  NOT?: Maybe<GqlEnumValueScalarWhereInput[] | GqlEnumValueScalarWhereInput>;
}

export interface GqlEnumValueUpdateManyWithWhereNestedInput {
  where: GqlEnumValueScalarWhereInput;
  data: GqlEnumValueUpdateManyDataInput;
}

export interface GqlEnumValueUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  isDeprecated?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
}

export interface GqlTypeUpsertWithoutCommentsInput {
  update: GqlTypeUpdateWithoutCommentsDataInput;
  create: GqlTypeCreateWithoutCommentsInput;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  sub?: Maybe<String>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  profile?: Maybe<UserProfileUpdateOneInput>;
  schemas?: Maybe<GqlSchemaUpdateManyWithoutMembersInput>;
}

export interface UserProfileUpdateOneInput {
  create?: Maybe<UserProfileCreateInput>;
  update?: Maybe<UserProfileUpdateDataInput>;
  upsert?: Maybe<UserProfileUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserProfileWhereUniqueInput>;
}

export interface UserProfileUpdateDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  fullName?: Maybe<String>;
  picture?: Maybe<String>;
}

export interface UserProfileUpsertNestedInput {
  update: UserProfileUpdateDataInput;
  create: UserProfileCreateInput;
}

export interface GqlSchemaUpdateManyWithoutMembersInput {
  create?: Maybe<
    GqlSchemaCreateWithoutMembersInput[] | GqlSchemaCreateWithoutMembersInput
  >;
  delete?: Maybe<GqlSchemaWhereUniqueInput[] | GqlSchemaWhereUniqueInput>;
  connect?: Maybe<GqlSchemaWhereUniqueInput[] | GqlSchemaWhereUniqueInput>;
  set?: Maybe<GqlSchemaWhereUniqueInput[] | GqlSchemaWhereUniqueInput>;
  disconnect?: Maybe<GqlSchemaWhereUniqueInput[] | GqlSchemaWhereUniqueInput>;
  update?: Maybe<
    | GqlSchemaUpdateWithWhereUniqueWithoutMembersInput[]
    | GqlSchemaUpdateWithWhereUniqueWithoutMembersInput
  >;
  upsert?: Maybe<
    | GqlSchemaUpsertWithWhereUniqueWithoutMembersInput[]
    | GqlSchemaUpsertWithWhereUniqueWithoutMembersInput
  >;
  deleteMany?: Maybe<GqlSchemaScalarWhereInput[] | GqlSchemaScalarWhereInput>;
  updateMany?: Maybe<
    | GqlSchemaUpdateManyWithWhereNestedInput[]
    | GqlSchemaUpdateManyWithWhereNestedInput
  >;
}

export interface GqlSchemaUpdateWithWhereUniqueWithoutMembersInput {
  where: GqlSchemaWhereUniqueInput;
  data: GqlSchemaUpdateWithoutMembersDataInput;
}

export interface GqlSchemaUpdateWithoutMembersDataInput {
  name?: Maybe<String>;
  owner?: Maybe<UserUpdateOneInput>;
  apiKey?: Maybe<String>;
  introspectionSchema?: Maybe<GqlIntrospectionSchemaUpdateOneInput>;
  endpointUrl?: Maybe<String>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface GqlIntrospectionSchemaUpdateOneInput {
  create?: Maybe<GqlIntrospectionSchemaCreateInput>;
  update?: Maybe<GqlIntrospectionSchemaUpdateDataInput>;
  upsert?: Maybe<GqlIntrospectionSchemaUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<GqlIntrospectionSchemaWhereUniqueInput>;
}

export interface GqlIntrospectionSchemaUpdateDataInput {
  name?: Maybe<String>;
  types?: Maybe<GqlTypeUpdateManyWithoutSchemaInput>;
  directives?: Maybe<GqlDirectiveUpdateManyInput>;
}

export interface GqlTypeUpdateManyWithoutSchemaInput {
  create?: Maybe<
    GqlTypeCreateWithoutSchemaInput[] | GqlTypeCreateWithoutSchemaInput
  >;
  delete?: Maybe<GqlTypeWhereUniqueInput[] | GqlTypeWhereUniqueInput>;
  connect?: Maybe<GqlTypeWhereUniqueInput[] | GqlTypeWhereUniqueInput>;
  set?: Maybe<GqlTypeWhereUniqueInput[] | GqlTypeWhereUniqueInput>;
  disconnect?: Maybe<GqlTypeWhereUniqueInput[] | GqlTypeWhereUniqueInput>;
  update?: Maybe<
    | GqlTypeUpdateWithWhereUniqueWithoutSchemaInput[]
    | GqlTypeUpdateWithWhereUniqueWithoutSchemaInput
  >;
  upsert?: Maybe<
    | GqlTypeUpsertWithWhereUniqueWithoutSchemaInput[]
    | GqlTypeUpsertWithWhereUniqueWithoutSchemaInput
  >;
  deleteMany?: Maybe<GqlTypeScalarWhereInput[] | GqlTypeScalarWhereInput>;
  updateMany?: Maybe<
    | GqlTypeUpdateManyWithWhereNestedInput[]
    | GqlTypeUpdateManyWithWhereNestedInput
  >;
}

export interface GqlTypeUpdateWithWhereUniqueWithoutSchemaInput {
  where: GqlTypeWhereUniqueInput;
  data: GqlTypeUpdateWithoutSchemaDataInput;
}

export interface GqlTypeUpdateWithoutSchemaDataInput {
  kind?: Maybe<GqlTypeKind>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  fields?: Maybe<GqlFieldUpdateManyInput>;
  interfaces?: Maybe<GqlBaseTypeUpdateManyInput>;
  possibleTypes?: Maybe<GqlBaseTypeUpdateManyInput>;
  enumValues?: Maybe<GqlEnumValueUpdateManyInput>;
  inputFields?: Maybe<GqlInputValueUpdateManyInput>;
  comments?: Maybe<CommentUpdateManyWithoutGqlTypeInput>;
}

export interface CommentUpdateManyWithoutGqlTypeInput {
  create?: Maybe<
    CommentCreateWithoutGqlTypeInput[] | CommentCreateWithoutGqlTypeInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutGqlTypeInput[]
    | CommentUpdateWithWhereUniqueWithoutGqlTypeInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutGqlTypeInput[]
    | CommentUpsertWithWhereUniqueWithoutGqlTypeInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface CommentUpdateWithWhereUniqueWithoutGqlTypeInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutGqlTypeDataInput;
}

export interface CommentUpdateWithoutGqlTypeDataInput {
  content?: Maybe<CommentContentUpdateOneRequiredInput>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutGqlTypeInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutGqlTypeDataInput;
  create: CommentCreateWithoutGqlTypeInput;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface GqlTypeUpsertWithWhereUniqueWithoutSchemaInput {
  where: GqlTypeWhereUniqueInput;
  update: GqlTypeUpdateWithoutSchemaDataInput;
  create: GqlTypeCreateWithoutSchemaInput;
}

export interface GqlTypeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  kind?: Maybe<GqlTypeKind>;
  kind_not?: Maybe<GqlTypeKind>;
  kind_in?: Maybe<GqlTypeKind[] | GqlTypeKind>;
  kind_not_in?: Maybe<GqlTypeKind[] | GqlTypeKind>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<GqlTypeScalarWhereInput[] | GqlTypeScalarWhereInput>;
  OR?: Maybe<GqlTypeScalarWhereInput[] | GqlTypeScalarWhereInput>;
  NOT?: Maybe<GqlTypeScalarWhereInput[] | GqlTypeScalarWhereInput>;
}

export interface GqlTypeUpdateManyWithWhereNestedInput {
  where: GqlTypeScalarWhereInput;
  data: GqlTypeUpdateManyDataInput;
}

export interface GqlTypeUpdateManyDataInput {
  kind?: Maybe<GqlTypeKind>;
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface GqlIntrospectionSchemaUpsertNestedInput {
  update: GqlIntrospectionSchemaUpdateDataInput;
  create: GqlIntrospectionSchemaCreateInput;
}

export interface GqlSchemaUpsertWithWhereUniqueWithoutMembersInput {
  where: GqlSchemaWhereUniqueInput;
  update: GqlSchemaUpdateWithoutMembersDataInput;
  create: GqlSchemaCreateWithoutMembersInput;
}

export interface GqlSchemaScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  endpointUrl?: Maybe<String>;
  endpointUrl_not?: Maybe<String>;
  endpointUrl_in?: Maybe<String[] | String>;
  endpointUrl_not_in?: Maybe<String[] | String>;
  endpointUrl_lt?: Maybe<String>;
  endpointUrl_lte?: Maybe<String>;
  endpointUrl_gt?: Maybe<String>;
  endpointUrl_gte?: Maybe<String>;
  endpointUrl_contains?: Maybe<String>;
  endpointUrl_not_contains?: Maybe<String>;
  endpointUrl_starts_with?: Maybe<String>;
  endpointUrl_not_starts_with?: Maybe<String>;
  endpointUrl_ends_with?: Maybe<String>;
  endpointUrl_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GqlSchemaScalarWhereInput[] | GqlSchemaScalarWhereInput>;
  OR?: Maybe<GqlSchemaScalarWhereInput[] | GqlSchemaScalarWhereInput>;
  NOT?: Maybe<GqlSchemaScalarWhereInput[] | GqlSchemaScalarWhereInput>;
}

export interface GqlSchemaUpdateManyWithWhereNestedInput {
  where: GqlSchemaScalarWhereInput;
  data: GqlSchemaUpdateManyDataInput;
}

export interface GqlSchemaUpdateManyDataInput {
  name?: Maybe<String>;
  apiKey?: Maybe<String>;
  endpointUrl?: Maybe<String>;
}

export interface CommentContentUpdateInput {
  message?: Maybe<String>;
}

export interface CommentContentUpdateManyMutationInput {
  message?: Maybe<String>;
}

export interface GqlBaseTypeUpdateInput {
  kind?: Maybe<GqlTypeKind>;
  name?: Maybe<String>;
}

export interface GqlBaseTypeUpdateManyMutationInput {
  kind?: Maybe<GqlTypeKind>;
  name?: Maybe<String>;
}

export interface GqlDirectiveUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  locations?: Maybe<GqlDirectiveUpdatelocationsInput>;
  args?: Maybe<GqlInputValueUpdateManyInput>;
}

export interface GqlDirectiveUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  locations?: Maybe<GqlDirectiveUpdatelocationsInput>;
}

export interface GqlEnumValueUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  isDeprecated?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
}

export interface GqlEnumValueUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  isDeprecated?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
}

export interface GqlFieldUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  typeName?: Maybe<String>;
  kinds?: Maybe<GqlFieldUpdatekindsInput>;
  args?: Maybe<GqlInputValueUpdateManyInput>;
  isDeprecated?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
}

export interface GqlFieldUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  typeName?: Maybe<String>;
  kinds?: Maybe<GqlFieldUpdatekindsInput>;
  isDeprecated?: Maybe<Boolean>;
  deprecationReason?: Maybe<String>;
}

export interface GqlInputValueUpdateInput {
  name?: Maybe<String>;
  kinds?: Maybe<GqlInputValueUpdatekindsInput>;
  typeName?: Maybe<String>;
  description?: Maybe<String>;
  defaultValue?: Maybe<String>;
}

export interface GqlInputValueUpdateManyMutationInput {
  name?: Maybe<String>;
  kinds?: Maybe<GqlInputValueUpdatekindsInput>;
  typeName?: Maybe<String>;
  description?: Maybe<String>;
  defaultValue?: Maybe<String>;
}

export interface GqlIntrospectionSchemaUpdateInput {
  name?: Maybe<String>;
  types?: Maybe<GqlTypeUpdateManyWithoutSchemaInput>;
  directives?: Maybe<GqlDirectiveUpdateManyInput>;
}

export interface GqlIntrospectionSchemaUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface GqlSchemaCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  owner?: Maybe<UserCreateOneInput>;
  members?: Maybe<UserCreateManyWithoutSchemasInput>;
  apiKey: String;
  introspectionSchema?: Maybe<GqlIntrospectionSchemaCreateOneInput>;
  endpointUrl?: Maybe<String>;
}

export interface UserCreateManyWithoutSchemasInput {
  create?: Maybe<
    UserCreateWithoutSchemasInput[] | UserCreateWithoutSchemasInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutSchemasInput {
  id?: Maybe<ID_Input>;
  sub: String;
  email: String;
  username: String;
  profile?: Maybe<UserProfileCreateOneInput>;
}

export interface GqlSchemaUpdateInput {
  name?: Maybe<String>;
  owner?: Maybe<UserUpdateOneInput>;
  members?: Maybe<UserUpdateManyWithoutSchemasInput>;
  apiKey?: Maybe<String>;
  introspectionSchema?: Maybe<GqlIntrospectionSchemaUpdateOneInput>;
  endpointUrl?: Maybe<String>;
}

export interface UserUpdateManyWithoutSchemasInput {
  create?: Maybe<
    UserCreateWithoutSchemasInput[] | UserCreateWithoutSchemasInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutSchemasInput[]
    | UserUpdateWithWhereUniqueWithoutSchemasInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutSchemasInput[]
    | UserUpsertWithWhereUniqueWithoutSchemasInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutSchemasInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSchemasDataInput;
}

export interface UserUpdateWithoutSchemasDataInput {
  sub?: Maybe<String>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  profile?: Maybe<UserProfileUpdateOneInput>;
}

export interface UserUpsertWithWhereUniqueWithoutSchemasInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSchemasDataInput;
  create: UserCreateWithoutSchemasInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  sub?: Maybe<String>;
  sub_not?: Maybe<String>;
  sub_in?: Maybe<String[] | String>;
  sub_not_in?: Maybe<String[] | String>;
  sub_lt?: Maybe<String>;
  sub_lte?: Maybe<String>;
  sub_gt?: Maybe<String>;
  sub_gte?: Maybe<String>;
  sub_contains?: Maybe<String>;
  sub_not_contains?: Maybe<String>;
  sub_starts_with?: Maybe<String>;
  sub_not_starts_with?: Maybe<String>;
  sub_ends_with?: Maybe<String>;
  sub_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  sub?: Maybe<String>;
  email?: Maybe<String>;
  username?: Maybe<String>;
}

export interface GqlSchemaUpdateManyMutationInput {
  name?: Maybe<String>;
  apiKey?: Maybe<String>;
  endpointUrl?: Maybe<String>;
}

export interface GqlTypeCreateInput {
  id?: Maybe<ID_Input>;
  kind: GqlTypeKind;
  name?: Maybe<String>;
  description?: Maybe<String>;
  schema: GqlIntrospectionSchemaCreateOneWithoutTypesInput;
  fields?: Maybe<GqlFieldCreateManyInput>;
  interfaces?: Maybe<GqlBaseTypeCreateManyInput>;
  possibleTypes?: Maybe<GqlBaseTypeCreateManyInput>;
  enumValues?: Maybe<GqlEnumValueCreateManyInput>;
  inputFields?: Maybe<GqlInputValueCreateManyInput>;
  comments?: Maybe<CommentCreateManyWithoutGqlTypeInput>;
}

export interface GqlTypeUpdateInput {
  kind?: Maybe<GqlTypeKind>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  schema?: Maybe<GqlIntrospectionSchemaUpdateOneRequiredWithoutTypesInput>;
  fields?: Maybe<GqlFieldUpdateManyInput>;
  interfaces?: Maybe<GqlBaseTypeUpdateManyInput>;
  possibleTypes?: Maybe<GqlBaseTypeUpdateManyInput>;
  enumValues?: Maybe<GqlEnumValueUpdateManyInput>;
  inputFields?: Maybe<GqlInputValueUpdateManyInput>;
  comments?: Maybe<CommentUpdateManyWithoutGqlTypeInput>;
}

export interface GqlTypeUpdateManyMutationInput {
  kind?: Maybe<GqlTypeKind>;
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserUpdateInput {
  sub?: Maybe<String>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  profile?: Maybe<UserProfileUpdateOneInput>;
  schemas?: Maybe<GqlSchemaUpdateManyWithoutMembersInput>;
}

export interface UserUpdateManyMutationInput {
  sub?: Maybe<String>;
  email?: Maybe<String>;
  username?: Maybe<String>;
}

export interface UserProfileUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  fullName?: Maybe<String>;
  picture?: Maybe<String>;
}

export interface UserProfileUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  fullName?: Maybe<String>;
  picture?: Maybe<String>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface CommentContentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentContentWhereInput>;
  AND?: Maybe<
    | CommentContentSubscriptionWhereInput[]
    | CommentContentSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CommentContentSubscriptionWhereInput[]
    | CommentContentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CommentContentSubscriptionWhereInput[]
    | CommentContentSubscriptionWhereInput
  >;
}

export interface GqlBaseTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GqlBaseTypeWhereInput>;
  AND?: Maybe<
    GqlBaseTypeSubscriptionWhereInput[] | GqlBaseTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    GqlBaseTypeSubscriptionWhereInput[] | GqlBaseTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    GqlBaseTypeSubscriptionWhereInput[] | GqlBaseTypeSubscriptionWhereInput
  >;
}

export interface GqlDirectiveSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GqlDirectiveWhereInput>;
  AND?: Maybe<
    GqlDirectiveSubscriptionWhereInput[] | GqlDirectiveSubscriptionWhereInput
  >;
  OR?: Maybe<
    GqlDirectiveSubscriptionWhereInput[] | GqlDirectiveSubscriptionWhereInput
  >;
  NOT?: Maybe<
    GqlDirectiveSubscriptionWhereInput[] | GqlDirectiveSubscriptionWhereInput
  >;
}

export interface GqlEnumValueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GqlEnumValueWhereInput>;
  AND?: Maybe<
    GqlEnumValueSubscriptionWhereInput[] | GqlEnumValueSubscriptionWhereInput
  >;
  OR?: Maybe<
    GqlEnumValueSubscriptionWhereInput[] | GqlEnumValueSubscriptionWhereInput
  >;
  NOT?: Maybe<
    GqlEnumValueSubscriptionWhereInput[] | GqlEnumValueSubscriptionWhereInput
  >;
}

export interface GqlFieldSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GqlFieldWhereInput>;
  AND?: Maybe<
    GqlFieldSubscriptionWhereInput[] | GqlFieldSubscriptionWhereInput
  >;
  OR?: Maybe<GqlFieldSubscriptionWhereInput[] | GqlFieldSubscriptionWhereInput>;
  NOT?: Maybe<
    GqlFieldSubscriptionWhereInput[] | GqlFieldSubscriptionWhereInput
  >;
}

export interface GqlInputValueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GqlInputValueWhereInput>;
  AND?: Maybe<
    GqlInputValueSubscriptionWhereInput[] | GqlInputValueSubscriptionWhereInput
  >;
  OR?: Maybe<
    GqlInputValueSubscriptionWhereInput[] | GqlInputValueSubscriptionWhereInput
  >;
  NOT?: Maybe<
    GqlInputValueSubscriptionWhereInput[] | GqlInputValueSubscriptionWhereInput
  >;
}

export interface GqlIntrospectionSchemaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GqlIntrospectionSchemaWhereInput>;
  AND?: Maybe<
    | GqlIntrospectionSchemaSubscriptionWhereInput[]
    | GqlIntrospectionSchemaSubscriptionWhereInput
  >;
  OR?: Maybe<
    | GqlIntrospectionSchemaSubscriptionWhereInput[]
    | GqlIntrospectionSchemaSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | GqlIntrospectionSchemaSubscriptionWhereInput[]
    | GqlIntrospectionSchemaSubscriptionWhereInput
  >;
}

export interface GqlSchemaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GqlSchemaWhereInput>;
  AND?: Maybe<
    GqlSchemaSubscriptionWhereInput[] | GqlSchemaSubscriptionWhereInput
  >;
  OR?: Maybe<
    GqlSchemaSubscriptionWhereInput[] | GqlSchemaSubscriptionWhereInput
  >;
  NOT?: Maybe<
    GqlSchemaSubscriptionWhereInput[] | GqlSchemaSubscriptionWhereInput
  >;
}

export interface GqlTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GqlTypeWhereInput>;
  AND?: Maybe<GqlTypeSubscriptionWhereInput[] | GqlTypeSubscriptionWhereInput>;
  OR?: Maybe<GqlTypeSubscriptionWhereInput[] | GqlTypeSubscriptionWhereInput>;
  NOT?: Maybe<GqlTypeSubscriptionWhereInput[] | GqlTypeSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserProfileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserProfileWhereInput>;
  AND?: Maybe<
    UserProfileSubscriptionWhereInput[] | UserProfileSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserProfileSubscriptionWhereInput[] | UserProfileSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserProfileSubscriptionWhereInput[] | UserProfileSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Comment {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  content: <T = CommentContentPromise>() => T;
  gqlType: <T = GqlTypePromise>() => T;
  createdBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: <T = CommentContentSubscription>() => T;
  gqlType: <T = GqlTypeSubscription>() => T;
  createdBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: <T = CommentContentPromise>() => T;
  gqlType: <T = GqlTypePromise>() => T;
  createdBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentContent {
  id: ID_Output;
  message: String;
}

export interface CommentContentPromise
  extends Promise<CommentContent>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
}

export interface CommentContentSubscription
  extends Promise<AsyncIterator<CommentContent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
}

export interface CommentContentNullablePromise
  extends Promise<CommentContent | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
}

export interface GqlType {
  id: ID_Output;
  kind: GqlTypeKind;
  name?: String;
  description?: String;
}

export interface GqlTypePromise extends Promise<GqlType>, Fragmentable {
  id: () => Promise<ID_Output>;
  kind: () => Promise<GqlTypeKind>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  schema: <T = GqlIntrospectionSchemaPromise>() => T;
  fields: <T = FragmentableArray<GqlField>>(args?: {
    where?: GqlFieldWhereInput;
    orderBy?: GqlFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interfaces: <T = FragmentableArray<GqlBaseType>>(args?: {
    where?: GqlBaseTypeWhereInput;
    orderBy?: GqlBaseTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  possibleTypes: <T = FragmentableArray<GqlBaseType>>(args?: {
    where?: GqlBaseTypeWhereInput;
    orderBy?: GqlBaseTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  enumValues: <T = FragmentableArray<GqlEnumValue>>(args?: {
    where?: GqlEnumValueWhereInput;
    orderBy?: GqlEnumValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  inputFields: <T = FragmentableArray<GqlInputValue>>(args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GqlTypeSubscription
  extends Promise<AsyncIterator<GqlType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  kind: () => Promise<AsyncIterator<GqlTypeKind>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  schema: <T = GqlIntrospectionSchemaSubscription>() => T;
  fields: <T = Promise<AsyncIterator<GqlFieldSubscription>>>(args?: {
    where?: GqlFieldWhereInput;
    orderBy?: GqlFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interfaces: <T = Promise<AsyncIterator<GqlBaseTypeSubscription>>>(args?: {
    where?: GqlBaseTypeWhereInput;
    orderBy?: GqlBaseTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  possibleTypes: <T = Promise<AsyncIterator<GqlBaseTypeSubscription>>>(args?: {
    where?: GqlBaseTypeWhereInput;
    orderBy?: GqlBaseTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  enumValues: <T = Promise<AsyncIterator<GqlEnumValueSubscription>>>(args?: {
    where?: GqlEnumValueWhereInput;
    orderBy?: GqlEnumValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  inputFields: <T = Promise<AsyncIterator<GqlInputValueSubscription>>>(args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GqlTypeNullablePromise
  extends Promise<GqlType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  kind: () => Promise<GqlTypeKind>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  schema: <T = GqlIntrospectionSchemaPromise>() => T;
  fields: <T = FragmentableArray<GqlField>>(args?: {
    where?: GqlFieldWhereInput;
    orderBy?: GqlFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interfaces: <T = FragmentableArray<GqlBaseType>>(args?: {
    where?: GqlBaseTypeWhereInput;
    orderBy?: GqlBaseTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  possibleTypes: <T = FragmentableArray<GqlBaseType>>(args?: {
    where?: GqlBaseTypeWhereInput;
    orderBy?: GqlBaseTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  enumValues: <T = FragmentableArray<GqlEnumValue>>(args?: {
    where?: GqlEnumValueWhereInput;
    orderBy?: GqlEnumValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  inputFields: <T = FragmentableArray<GqlInputValue>>(args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GqlIntrospectionSchema {
  id: ID_Output;
  name: String;
}

export interface GqlIntrospectionSchemaPromise
  extends Promise<GqlIntrospectionSchema>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  types: <T = FragmentableArray<GqlType>>(args?: {
    where?: GqlTypeWhereInput;
    orderBy?: GqlTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  directives: <T = FragmentableArray<GqlDirective>>(args?: {
    where?: GqlDirectiveWhereInput;
    orderBy?: GqlDirectiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GqlIntrospectionSchemaSubscription
  extends Promise<AsyncIterator<GqlIntrospectionSchema>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  types: <T = Promise<AsyncIterator<GqlTypeSubscription>>>(args?: {
    where?: GqlTypeWhereInput;
    orderBy?: GqlTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  directives: <T = Promise<AsyncIterator<GqlDirectiveSubscription>>>(args?: {
    where?: GqlDirectiveWhereInput;
    orderBy?: GqlDirectiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GqlIntrospectionSchemaNullablePromise
  extends Promise<GqlIntrospectionSchema | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  types: <T = FragmentableArray<GqlType>>(args?: {
    where?: GqlTypeWhereInput;
    orderBy?: GqlTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  directives: <T = FragmentableArray<GqlDirective>>(args?: {
    where?: GqlDirectiveWhereInput;
    orderBy?: GqlDirectiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GqlDirective {
  id: ID_Output;
  name: String;
  description?: String;
  locations: GqlDirectiveLocation[];
}

export interface GqlDirectivePromise
  extends Promise<GqlDirective>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  locations: () => Promise<GqlDirectiveLocation[]>;
  args: <T = FragmentableArray<GqlInputValue>>(args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GqlDirectiveSubscription
  extends Promise<AsyncIterator<GqlDirective>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  locations: () => Promise<AsyncIterator<GqlDirectiveLocation[]>>;
  args: <T = Promise<AsyncIterator<GqlInputValueSubscription>>>(args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GqlDirectiveNullablePromise
  extends Promise<GqlDirective | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  locations: () => Promise<GqlDirectiveLocation[]>;
  args: <T = FragmentableArray<GqlInputValue>>(args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GqlInputValue {
  id: ID_Output;
  name: String;
  kinds: GqlTypeKind[];
  typeName?: String;
  description?: String;
  defaultValue?: String;
}

export interface GqlInputValuePromise
  extends Promise<GqlInputValue>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  kinds: () => Promise<GqlTypeKind[]>;
  typeName: () => Promise<String>;
  description: () => Promise<String>;
  defaultValue: () => Promise<String>;
}

export interface GqlInputValueSubscription
  extends Promise<AsyncIterator<GqlInputValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  kinds: () => Promise<AsyncIterator<GqlTypeKind[]>>;
  typeName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  defaultValue: () => Promise<AsyncIterator<String>>;
}

export interface GqlInputValueNullablePromise
  extends Promise<GqlInputValue | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  kinds: () => Promise<GqlTypeKind[]>;
  typeName: () => Promise<String>;
  description: () => Promise<String>;
  defaultValue: () => Promise<String>;
}

export interface GqlField {
  id: ID_Output;
  name: String;
  description?: String;
  typeName?: String;
  kinds: GqlTypeKind[];
  isDeprecated: Boolean;
  deprecationReason?: String;
}

export interface GqlFieldPromise extends Promise<GqlField>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  typeName: () => Promise<String>;
  kinds: () => Promise<GqlTypeKind[]>;
  args: <T = FragmentableArray<GqlInputValue>>(args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isDeprecated: () => Promise<Boolean>;
  deprecationReason: () => Promise<String>;
}

export interface GqlFieldSubscription
  extends Promise<AsyncIterator<GqlField>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  typeName: () => Promise<AsyncIterator<String>>;
  kinds: () => Promise<AsyncIterator<GqlTypeKind[]>>;
  args: <T = Promise<AsyncIterator<GqlInputValueSubscription>>>(args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isDeprecated: () => Promise<AsyncIterator<Boolean>>;
  deprecationReason: () => Promise<AsyncIterator<String>>;
}

export interface GqlFieldNullablePromise
  extends Promise<GqlField | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  typeName: () => Promise<String>;
  kinds: () => Promise<GqlTypeKind[]>;
  args: <T = FragmentableArray<GqlInputValue>>(args?: {
    where?: GqlInputValueWhereInput;
    orderBy?: GqlInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isDeprecated: () => Promise<Boolean>;
  deprecationReason: () => Promise<String>;
}

export interface GqlBaseType {
  id: ID_Output;
  kind: GqlTypeKind;
  name: String;
}

export interface GqlBaseTypePromise extends Promise<GqlBaseType>, Fragmentable {
  id: () => Promise<ID_Output>;
  kind: () => Promise<GqlTypeKind>;
  name: () => Promise<String>;
}

export interface GqlBaseTypeSubscription
  extends Promise<AsyncIterator<GqlBaseType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  kind: () => Promise<AsyncIterator<GqlTypeKind>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface GqlBaseTypeNullablePromise
  extends Promise<GqlBaseType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  kind: () => Promise<GqlTypeKind>;
  name: () => Promise<String>;
}

export interface GqlEnumValue {
  id: ID_Output;
  name: String;
  description?: String;
  isDeprecated: Boolean;
  deprecationReason?: String;
}

export interface GqlEnumValuePromise
  extends Promise<GqlEnumValue>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  isDeprecated: () => Promise<Boolean>;
  deprecationReason: () => Promise<String>;
}

export interface GqlEnumValueSubscription
  extends Promise<AsyncIterator<GqlEnumValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isDeprecated: () => Promise<AsyncIterator<Boolean>>;
  deprecationReason: () => Promise<AsyncIterator<String>>;
}

export interface GqlEnumValueNullablePromise
  extends Promise<GqlEnumValue | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  isDeprecated: () => Promise<Boolean>;
  deprecationReason: () => Promise<String>;
}

export interface User {
  id: ID_Output;
  sub: String;
  email: String;
  username: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  sub: () => Promise<String>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  profile: <T = UserProfilePromise>() => T;
  schemas: <T = FragmentableArray<GqlSchema>>(args?: {
    where?: GqlSchemaWhereInput;
    orderBy?: GqlSchemaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sub: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  profile: <T = UserProfileSubscription>() => T;
  schemas: <T = Promise<AsyncIterator<GqlSchemaSubscription>>>(args?: {
    where?: GqlSchemaWhereInput;
    orderBy?: GqlSchemaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sub: () => Promise<String>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  profile: <T = UserProfilePromise>() => T;
  schemas: <T = FragmentableArray<GqlSchema>>(args?: {
    where?: GqlSchemaWhereInput;
    orderBy?: GqlSchemaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserProfile {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  fullName?: String;
  picture?: String;
}

export interface UserProfilePromise extends Promise<UserProfile>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  fullName: () => Promise<String>;
  picture: () => Promise<String>;
}

export interface UserProfileSubscription
  extends Promise<AsyncIterator<UserProfile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  fullName: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
}

export interface UserProfileNullablePromise
  extends Promise<UserProfile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  fullName: () => Promise<String>;
  picture: () => Promise<String>;
}

export interface GqlSchema {
  id: ID_Output;
  name: String;
  apiKey: String;
  endpointUrl?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GqlSchemaPromise extends Promise<GqlSchema>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  owner: <T = UserPromise>() => T;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  apiKey: () => Promise<String>;
  introspectionSchema: <T = GqlIntrospectionSchemaPromise>() => T;
  endpointUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GqlSchemaSubscription
  extends Promise<AsyncIterator<GqlSchema>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  apiKey: () => Promise<AsyncIterator<String>>;
  introspectionSchema: <T = GqlIntrospectionSchemaSubscription>() => T;
  endpointUrl: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GqlSchemaNullablePromise
  extends Promise<GqlSchema | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  owner: <T = UserPromise>() => T;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  apiKey: () => Promise<String>;
  introspectionSchema: <T = GqlIntrospectionSchemaPromise>() => T;
  endpointUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentContentConnection {
  pageInfo: PageInfo;
  edges: CommentContentEdge[];
}

export interface CommentContentConnectionPromise
  extends Promise<CommentContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentContentEdge>>() => T;
  aggregate: <T = AggregateCommentContentPromise>() => T;
}

export interface CommentContentConnectionSubscription
  extends Promise<AsyncIterator<CommentContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentContentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentContentSubscription>() => T;
}

export interface CommentContentEdge {
  node: CommentContent;
  cursor: String;
}

export interface CommentContentEdgePromise
  extends Promise<CommentContentEdge>,
    Fragmentable {
  node: <T = CommentContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentContentEdgeSubscription
  extends Promise<AsyncIterator<CommentContentEdge>>,
    Fragmentable {
  node: <T = CommentContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCommentContent {
  count: Int;
}

export interface AggregateCommentContentPromise
  extends Promise<AggregateCommentContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentContentSubscription
  extends Promise<AsyncIterator<AggregateCommentContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GqlBaseTypeConnection {
  pageInfo: PageInfo;
  edges: GqlBaseTypeEdge[];
}

export interface GqlBaseTypeConnectionPromise
  extends Promise<GqlBaseTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GqlBaseTypeEdge>>() => T;
  aggregate: <T = AggregateGqlBaseTypePromise>() => T;
}

export interface GqlBaseTypeConnectionSubscription
  extends Promise<AsyncIterator<GqlBaseTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GqlBaseTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGqlBaseTypeSubscription>() => T;
}

export interface GqlBaseTypeEdge {
  node: GqlBaseType;
  cursor: String;
}

export interface GqlBaseTypeEdgePromise
  extends Promise<GqlBaseTypeEdge>,
    Fragmentable {
  node: <T = GqlBaseTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GqlBaseTypeEdgeSubscription
  extends Promise<AsyncIterator<GqlBaseTypeEdge>>,
    Fragmentable {
  node: <T = GqlBaseTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGqlBaseType {
  count: Int;
}

export interface AggregateGqlBaseTypePromise
  extends Promise<AggregateGqlBaseType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGqlBaseTypeSubscription
  extends Promise<AsyncIterator<AggregateGqlBaseType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GqlDirectiveConnection {
  pageInfo: PageInfo;
  edges: GqlDirectiveEdge[];
}

export interface GqlDirectiveConnectionPromise
  extends Promise<GqlDirectiveConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GqlDirectiveEdge>>() => T;
  aggregate: <T = AggregateGqlDirectivePromise>() => T;
}

export interface GqlDirectiveConnectionSubscription
  extends Promise<AsyncIterator<GqlDirectiveConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GqlDirectiveEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGqlDirectiveSubscription>() => T;
}

export interface GqlDirectiveEdge {
  node: GqlDirective;
  cursor: String;
}

export interface GqlDirectiveEdgePromise
  extends Promise<GqlDirectiveEdge>,
    Fragmentable {
  node: <T = GqlDirectivePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GqlDirectiveEdgeSubscription
  extends Promise<AsyncIterator<GqlDirectiveEdge>>,
    Fragmentable {
  node: <T = GqlDirectiveSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGqlDirective {
  count: Int;
}

export interface AggregateGqlDirectivePromise
  extends Promise<AggregateGqlDirective>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGqlDirectiveSubscription
  extends Promise<AsyncIterator<AggregateGqlDirective>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GqlEnumValueConnection {
  pageInfo: PageInfo;
  edges: GqlEnumValueEdge[];
}

export interface GqlEnumValueConnectionPromise
  extends Promise<GqlEnumValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GqlEnumValueEdge>>() => T;
  aggregate: <T = AggregateGqlEnumValuePromise>() => T;
}

export interface GqlEnumValueConnectionSubscription
  extends Promise<AsyncIterator<GqlEnumValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GqlEnumValueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGqlEnumValueSubscription>() => T;
}

export interface GqlEnumValueEdge {
  node: GqlEnumValue;
  cursor: String;
}

export interface GqlEnumValueEdgePromise
  extends Promise<GqlEnumValueEdge>,
    Fragmentable {
  node: <T = GqlEnumValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GqlEnumValueEdgeSubscription
  extends Promise<AsyncIterator<GqlEnumValueEdge>>,
    Fragmentable {
  node: <T = GqlEnumValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGqlEnumValue {
  count: Int;
}

export interface AggregateGqlEnumValuePromise
  extends Promise<AggregateGqlEnumValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGqlEnumValueSubscription
  extends Promise<AsyncIterator<AggregateGqlEnumValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GqlFieldConnection {
  pageInfo: PageInfo;
  edges: GqlFieldEdge[];
}

export interface GqlFieldConnectionPromise
  extends Promise<GqlFieldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GqlFieldEdge>>() => T;
  aggregate: <T = AggregateGqlFieldPromise>() => T;
}

export interface GqlFieldConnectionSubscription
  extends Promise<AsyncIterator<GqlFieldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GqlFieldEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGqlFieldSubscription>() => T;
}

export interface GqlFieldEdge {
  node: GqlField;
  cursor: String;
}

export interface GqlFieldEdgePromise
  extends Promise<GqlFieldEdge>,
    Fragmentable {
  node: <T = GqlFieldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GqlFieldEdgeSubscription
  extends Promise<AsyncIterator<GqlFieldEdge>>,
    Fragmentable {
  node: <T = GqlFieldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGqlField {
  count: Int;
}

export interface AggregateGqlFieldPromise
  extends Promise<AggregateGqlField>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGqlFieldSubscription
  extends Promise<AsyncIterator<AggregateGqlField>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GqlInputValueConnection {
  pageInfo: PageInfo;
  edges: GqlInputValueEdge[];
}

export interface GqlInputValueConnectionPromise
  extends Promise<GqlInputValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GqlInputValueEdge>>() => T;
  aggregate: <T = AggregateGqlInputValuePromise>() => T;
}

export interface GqlInputValueConnectionSubscription
  extends Promise<AsyncIterator<GqlInputValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GqlInputValueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGqlInputValueSubscription>() => T;
}

export interface GqlInputValueEdge {
  node: GqlInputValue;
  cursor: String;
}

export interface GqlInputValueEdgePromise
  extends Promise<GqlInputValueEdge>,
    Fragmentable {
  node: <T = GqlInputValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GqlInputValueEdgeSubscription
  extends Promise<AsyncIterator<GqlInputValueEdge>>,
    Fragmentable {
  node: <T = GqlInputValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGqlInputValue {
  count: Int;
}

export interface AggregateGqlInputValuePromise
  extends Promise<AggregateGqlInputValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGqlInputValueSubscription
  extends Promise<AsyncIterator<AggregateGqlInputValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GqlIntrospectionSchemaConnection {
  pageInfo: PageInfo;
  edges: GqlIntrospectionSchemaEdge[];
}

export interface GqlIntrospectionSchemaConnectionPromise
  extends Promise<GqlIntrospectionSchemaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GqlIntrospectionSchemaEdge>>() => T;
  aggregate: <T = AggregateGqlIntrospectionSchemaPromise>() => T;
}

export interface GqlIntrospectionSchemaConnectionSubscription
  extends Promise<AsyncIterator<GqlIntrospectionSchemaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GqlIntrospectionSchemaEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGqlIntrospectionSchemaSubscription>() => T;
}

export interface GqlIntrospectionSchemaEdge {
  node: GqlIntrospectionSchema;
  cursor: String;
}

export interface GqlIntrospectionSchemaEdgePromise
  extends Promise<GqlIntrospectionSchemaEdge>,
    Fragmentable {
  node: <T = GqlIntrospectionSchemaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GqlIntrospectionSchemaEdgeSubscription
  extends Promise<AsyncIterator<GqlIntrospectionSchemaEdge>>,
    Fragmentable {
  node: <T = GqlIntrospectionSchemaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGqlIntrospectionSchema {
  count: Int;
}

export interface AggregateGqlIntrospectionSchemaPromise
  extends Promise<AggregateGqlIntrospectionSchema>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGqlIntrospectionSchemaSubscription
  extends Promise<AsyncIterator<AggregateGqlIntrospectionSchema>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GqlSchemaConnection {
  pageInfo: PageInfo;
  edges: GqlSchemaEdge[];
}

export interface GqlSchemaConnectionPromise
  extends Promise<GqlSchemaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GqlSchemaEdge>>() => T;
  aggregate: <T = AggregateGqlSchemaPromise>() => T;
}

export interface GqlSchemaConnectionSubscription
  extends Promise<AsyncIterator<GqlSchemaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GqlSchemaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGqlSchemaSubscription>() => T;
}

export interface GqlSchemaEdge {
  node: GqlSchema;
  cursor: String;
}

export interface GqlSchemaEdgePromise
  extends Promise<GqlSchemaEdge>,
    Fragmentable {
  node: <T = GqlSchemaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GqlSchemaEdgeSubscription
  extends Promise<AsyncIterator<GqlSchemaEdge>>,
    Fragmentable {
  node: <T = GqlSchemaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGqlSchema {
  count: Int;
}

export interface AggregateGqlSchemaPromise
  extends Promise<AggregateGqlSchema>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGqlSchemaSubscription
  extends Promise<AsyncIterator<AggregateGqlSchema>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GqlTypeConnection {
  pageInfo: PageInfo;
  edges: GqlTypeEdge[];
}

export interface GqlTypeConnectionPromise
  extends Promise<GqlTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GqlTypeEdge>>() => T;
  aggregate: <T = AggregateGqlTypePromise>() => T;
}

export interface GqlTypeConnectionSubscription
  extends Promise<AsyncIterator<GqlTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GqlTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGqlTypeSubscription>() => T;
}

export interface GqlTypeEdge {
  node: GqlType;
  cursor: String;
}

export interface GqlTypeEdgePromise extends Promise<GqlTypeEdge>, Fragmentable {
  node: <T = GqlTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GqlTypeEdgeSubscription
  extends Promise<AsyncIterator<GqlTypeEdge>>,
    Fragmentable {
  node: <T = GqlTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGqlType {
  count: Int;
}

export interface AggregateGqlTypePromise
  extends Promise<AggregateGqlType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGqlTypeSubscription
  extends Promise<AsyncIterator<AggregateGqlType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserProfileConnection {
  pageInfo: PageInfo;
  edges: UserProfileEdge[];
}

export interface UserProfileConnectionPromise
  extends Promise<UserProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserProfileEdge>>() => T;
  aggregate: <T = AggregateUserProfilePromise>() => T;
}

export interface UserProfileConnectionSubscription
  extends Promise<AsyncIterator<UserProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserProfileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserProfileSubscription>() => T;
}

export interface UserProfileEdge {
  node: UserProfile;
  cursor: String;
}

export interface UserProfileEdgePromise
  extends Promise<UserProfileEdge>,
    Fragmentable {
  node: <T = UserProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserProfileEdgeSubscription
  extends Promise<AsyncIterator<UserProfileEdge>>,
    Fragmentable {
  node: <T = UserProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserProfile {
  count: Int;
}

export interface AggregateUserProfilePromise
  extends Promise<AggregateUserProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserProfileSubscription
  extends Promise<AsyncIterator<AggregateUserProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentContentSubscriptionPayload {
  mutation: MutationType;
  node: CommentContent;
  updatedFields: String[];
  previousValues: CommentContentPreviousValues;
}

export interface CommentContentSubscriptionPayloadPromise
  extends Promise<CommentContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentContentPreviousValuesPromise>() => T;
}

export interface CommentContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentContentPreviousValuesSubscription>() => T;
}

export interface CommentContentPreviousValues {
  id: ID_Output;
  message: String;
}

export interface CommentContentPreviousValuesPromise
  extends Promise<CommentContentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
}

export interface CommentContentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
}

export interface GqlBaseTypeSubscriptionPayload {
  mutation: MutationType;
  node: GqlBaseType;
  updatedFields: String[];
  previousValues: GqlBaseTypePreviousValues;
}

export interface GqlBaseTypeSubscriptionPayloadPromise
  extends Promise<GqlBaseTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GqlBaseTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GqlBaseTypePreviousValuesPromise>() => T;
}

export interface GqlBaseTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GqlBaseTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GqlBaseTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GqlBaseTypePreviousValuesSubscription>() => T;
}

export interface GqlBaseTypePreviousValues {
  id: ID_Output;
  kind: GqlTypeKind;
  name: String;
}

export interface GqlBaseTypePreviousValuesPromise
  extends Promise<GqlBaseTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  kind: () => Promise<GqlTypeKind>;
  name: () => Promise<String>;
}

export interface GqlBaseTypePreviousValuesSubscription
  extends Promise<AsyncIterator<GqlBaseTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  kind: () => Promise<AsyncIterator<GqlTypeKind>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface GqlDirectiveSubscriptionPayload {
  mutation: MutationType;
  node: GqlDirective;
  updatedFields: String[];
  previousValues: GqlDirectivePreviousValues;
}

export interface GqlDirectiveSubscriptionPayloadPromise
  extends Promise<GqlDirectiveSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GqlDirectivePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GqlDirectivePreviousValuesPromise>() => T;
}

export interface GqlDirectiveSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GqlDirectiveSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GqlDirectiveSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GqlDirectivePreviousValuesSubscription>() => T;
}

export interface GqlDirectivePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  locations: GqlDirectiveLocation[];
}

export interface GqlDirectivePreviousValuesPromise
  extends Promise<GqlDirectivePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  locations: () => Promise<GqlDirectiveLocation[]>;
}

export interface GqlDirectivePreviousValuesSubscription
  extends Promise<AsyncIterator<GqlDirectivePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  locations: () => Promise<AsyncIterator<GqlDirectiveLocation[]>>;
}

export interface GqlEnumValueSubscriptionPayload {
  mutation: MutationType;
  node: GqlEnumValue;
  updatedFields: String[];
  previousValues: GqlEnumValuePreviousValues;
}

export interface GqlEnumValueSubscriptionPayloadPromise
  extends Promise<GqlEnumValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GqlEnumValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GqlEnumValuePreviousValuesPromise>() => T;
}

export interface GqlEnumValueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GqlEnumValueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GqlEnumValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GqlEnumValuePreviousValuesSubscription>() => T;
}

export interface GqlEnumValuePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  isDeprecated: Boolean;
  deprecationReason?: String;
}

export interface GqlEnumValuePreviousValuesPromise
  extends Promise<GqlEnumValuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  isDeprecated: () => Promise<Boolean>;
  deprecationReason: () => Promise<String>;
}

export interface GqlEnumValuePreviousValuesSubscription
  extends Promise<AsyncIterator<GqlEnumValuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isDeprecated: () => Promise<AsyncIterator<Boolean>>;
  deprecationReason: () => Promise<AsyncIterator<String>>;
}

export interface GqlFieldSubscriptionPayload {
  mutation: MutationType;
  node: GqlField;
  updatedFields: String[];
  previousValues: GqlFieldPreviousValues;
}

export interface GqlFieldSubscriptionPayloadPromise
  extends Promise<GqlFieldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GqlFieldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GqlFieldPreviousValuesPromise>() => T;
}

export interface GqlFieldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GqlFieldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GqlFieldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GqlFieldPreviousValuesSubscription>() => T;
}

export interface GqlFieldPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  typeName?: String;
  kinds: GqlTypeKind[];
  isDeprecated: Boolean;
  deprecationReason?: String;
}

export interface GqlFieldPreviousValuesPromise
  extends Promise<GqlFieldPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  typeName: () => Promise<String>;
  kinds: () => Promise<GqlTypeKind[]>;
  isDeprecated: () => Promise<Boolean>;
  deprecationReason: () => Promise<String>;
}

export interface GqlFieldPreviousValuesSubscription
  extends Promise<AsyncIterator<GqlFieldPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  typeName: () => Promise<AsyncIterator<String>>;
  kinds: () => Promise<AsyncIterator<GqlTypeKind[]>>;
  isDeprecated: () => Promise<AsyncIterator<Boolean>>;
  deprecationReason: () => Promise<AsyncIterator<String>>;
}

export interface GqlInputValueSubscriptionPayload {
  mutation: MutationType;
  node: GqlInputValue;
  updatedFields: String[];
  previousValues: GqlInputValuePreviousValues;
}

export interface GqlInputValueSubscriptionPayloadPromise
  extends Promise<GqlInputValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GqlInputValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GqlInputValuePreviousValuesPromise>() => T;
}

export interface GqlInputValueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GqlInputValueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GqlInputValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GqlInputValuePreviousValuesSubscription>() => T;
}

export interface GqlInputValuePreviousValues {
  id: ID_Output;
  name: String;
  kinds: GqlTypeKind[];
  typeName?: String;
  description?: String;
  defaultValue?: String;
}

export interface GqlInputValuePreviousValuesPromise
  extends Promise<GqlInputValuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  kinds: () => Promise<GqlTypeKind[]>;
  typeName: () => Promise<String>;
  description: () => Promise<String>;
  defaultValue: () => Promise<String>;
}

export interface GqlInputValuePreviousValuesSubscription
  extends Promise<AsyncIterator<GqlInputValuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  kinds: () => Promise<AsyncIterator<GqlTypeKind[]>>;
  typeName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  defaultValue: () => Promise<AsyncIterator<String>>;
}

export interface GqlIntrospectionSchemaSubscriptionPayload {
  mutation: MutationType;
  node: GqlIntrospectionSchema;
  updatedFields: String[];
  previousValues: GqlIntrospectionSchemaPreviousValues;
}

export interface GqlIntrospectionSchemaSubscriptionPayloadPromise
  extends Promise<GqlIntrospectionSchemaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GqlIntrospectionSchemaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GqlIntrospectionSchemaPreviousValuesPromise>() => T;
}

export interface GqlIntrospectionSchemaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GqlIntrospectionSchemaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GqlIntrospectionSchemaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GqlIntrospectionSchemaPreviousValuesSubscription>() => T;
}

export interface GqlIntrospectionSchemaPreviousValues {
  id: ID_Output;
  name: String;
}

export interface GqlIntrospectionSchemaPreviousValuesPromise
  extends Promise<GqlIntrospectionSchemaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface GqlIntrospectionSchemaPreviousValuesSubscription
  extends Promise<AsyncIterator<GqlIntrospectionSchemaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface GqlSchemaSubscriptionPayload {
  mutation: MutationType;
  node: GqlSchema;
  updatedFields: String[];
  previousValues: GqlSchemaPreviousValues;
}

export interface GqlSchemaSubscriptionPayloadPromise
  extends Promise<GqlSchemaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GqlSchemaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GqlSchemaPreviousValuesPromise>() => T;
}

export interface GqlSchemaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GqlSchemaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GqlSchemaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GqlSchemaPreviousValuesSubscription>() => T;
}

export interface GqlSchemaPreviousValues {
  id: ID_Output;
  name: String;
  apiKey: String;
  endpointUrl?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GqlSchemaPreviousValuesPromise
  extends Promise<GqlSchemaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  apiKey: () => Promise<String>;
  endpointUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GqlSchemaPreviousValuesSubscription
  extends Promise<AsyncIterator<GqlSchemaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  endpointUrl: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GqlTypeSubscriptionPayload {
  mutation: MutationType;
  node: GqlType;
  updatedFields: String[];
  previousValues: GqlTypePreviousValues;
}

export interface GqlTypeSubscriptionPayloadPromise
  extends Promise<GqlTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GqlTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GqlTypePreviousValuesPromise>() => T;
}

export interface GqlTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GqlTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GqlTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GqlTypePreviousValuesSubscription>() => T;
}

export interface GqlTypePreviousValues {
  id: ID_Output;
  kind: GqlTypeKind;
  name?: String;
  description?: String;
}

export interface GqlTypePreviousValuesPromise
  extends Promise<GqlTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  kind: () => Promise<GqlTypeKind>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface GqlTypePreviousValuesSubscription
  extends Promise<AsyncIterator<GqlTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  kind: () => Promise<AsyncIterator<GqlTypeKind>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  sub: String;
  email: String;
  username: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sub: () => Promise<String>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sub: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserProfileSubscriptionPayload {
  mutation: MutationType;
  node: UserProfile;
  updatedFields: String[];
  previousValues: UserProfilePreviousValues;
}

export interface UserProfileSubscriptionPayloadPromise
  extends Promise<UserProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserProfilePreviousValuesPromise>() => T;
}

export interface UserProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserProfilePreviousValuesSubscription>() => T;
}

export interface UserProfilePreviousValues {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  fullName?: String;
  picture?: String;
}

export interface UserProfilePreviousValuesPromise
  extends Promise<UserProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  fullName: () => Promise<String>;
  picture: () => Promise<String>;
}

export interface UserProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<UserProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  fullName: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserProfile",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "CommentContent",
    embedded: false
  },
  {
    name: "GqlSchema",
    embedded: false
  },
  {
    name: "GqlIntrospectionSchema",
    embedded: false
  },
  {
    name: "GqlType",
    embedded: false
  },
  {
    name: "GqlBaseType",
    embedded: false
  },
  {
    name: "GqlField",
    embedded: false
  },
  {
    name: "GqlInputValue",
    embedded: false
  },
  {
    name: "GqlEnumValue",
    embedded: false
  },
  {
    name: "GqlDirective",
    embedded: false
  },
  {
    name: "GqlTypeKind",
    embedded: false
  },
  {
    name: "GqlDirectiveLocation",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
